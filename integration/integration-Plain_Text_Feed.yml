category: Data Enrichment & Threat Intelligence
commonfields:
  id: Plain Text Feed
  version: -1
configuration:
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- display: Server URL
  name: url
  required: true
  type: 0
- additionalinfo: It is possible to provide an API key header instead. See the description
    for more details.
  display: Username
  name: credentials
  required: false
  type: 9
- additionalinfo: If selected, the indicator type will be auto detected for each indicator.
  defaultvalue: "true"
  display: Auto detect indicator type
  name: auto_detect_type
  required: false
  type: 8
- additionalinfo: Type of the indicator in the feed. If auto-detect is checked then
    the value set as Indicator Type will be ignored. If the "Custom" option is selected,
    the Custom Indicator Type parameter must be provided.
  display: Indicator Type
  name: indicator_type
  options:
  - IP
  - CIDR
  - IPv6
  - IPv6CIDR
  - Domain
  - Email
  - URL
  - File
  - File MD5
  - File SHA256
  - File SHA1
  - Account
  - CVE
  - Host
  - ssdeep
  - Registry Key
  - Custom
  required: false
  type: 15
- additionalinfo: The indicator type to be used in case of 'Custom' option chosen
    in the Indicator Type field.
  display: Custom Indicator Type
  name: custom_indicator_type
  required: false
  type: 0
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation
  defaultvalue: feedInstanceReputationNotSet
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data
  defaultvalue: F - Reliability cannot be judged
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- defaultvalue: indicatorType
  display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- defaultvalue: "20160"
  display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "240"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- additionalinfo: Time (in seconds) before HTTP requests timeout
  defaultvalue: "20"
  display: Request Timeout
  name: polling_timeout
  required: true
  type: 0
- additionalinfo: Python regular expression for lines to ignore
  display: Ignore Regex
  name: ignore_regex
  required: false
  type: 0
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- display: Feed name
  name: feed_name
  required: false
  type: 0
- additionalinfo: JSON string of patterns to extract from the text response. See the
    description for more details.
  display: Indicator extraction pattern
  name: indicator
  required: false
  type: 12
- additionalinfo: JSON string of patterns to extract from the text response. See the
    description for more details.
  display: Fields extraction pattern
  name: fields
  required: false
  type: 12
- additionalinfo: CSV list of headers to send in the HTTP request in the format of
    "header_name:header_value".
  display: Headers
  name: headers
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 1.1.25
    packID: FeedPlainText
    packName: Plain Text Feed
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Fetches indicators from a plain text feed.
detaileddescription: "## Plain Text Feed Integration\n\nFetches indicators from a
  plain text feed. The integration allows a great amount of user configuration to
  support different types of plain text feeds.\n\n## Configuration\n\n* **Server URL**
  - URL of the feed.\n* **Indicator Type** - The type of indicators in the feed.\n*
  **Username + Password** - Credentials to access feeds that require basic authentication.
  \nThese fields also support the use of API key headers. To use API key headers,
  specify the header name and value in the following format:\n`_header:<header_name>`
  in the **Username** field and the header value in the **Password** field.\n* **Ignore
  Regex** - Python regular expression for lines that should be ignored.\n* **Indicator
  extraction pattern** - A JSON string of an extraction pattern for the indicator
  value in the text that consists of a regular expression and a transform template
  for each regex group. For example:\n```json\n{\n  \"regex\": \"^([0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3})\\\\t([0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3})\",\n
  \ \"transform\": \"\\\\1-\\\\2\"\n}\n```\n* **Fields extraction pattern** - A JSON
  string of an extraction pattern for the additional fields in the text that consists
  of a regular expression and a transform template for each regex group. For example:\n```json\n{\n
  \ \"number_of_attacks\":\n    {\n        \"regex\": \"^.*\\\\t.*\\\\t[0-9]+\\\\t([0-9]+)\",\n
  \       \"transform\": \"\\\\1\"\n    },\n  \"name\":\n     {  \n        \"regex\":
  \",^.*\\\\t.*\\\\t[0-9]+\\\\t[0-9]+\\\\t([^\\\\t]+)\",\n        \"transform\": \"\\\\1\"\n
  \    }\n}\n```\n\nFor more information about regular expression extraction, see
  the [Python documentation](https://docs.python.org/3/library/re.html#match-objects).\n\n*
  **Headers** -  CSV list of headers to send in the HTTP request in the format of
  \"header_name:header_value\". For example:\n\n`Content-Type:text/plain,Accept:application/json`\n\n\n##
  Step by step configuration\nAs an example, we'll be looking at the Recommended Block
  List feed by DShield. This feed will ingest indicators of type CIDR. These are the
  feed instance configuration parameters for our example.\n\n**Indicator Type** -
  CIDR.\n\n**Server URL**: https://www.dshield.org/block.txt\n\n**Credentials** -
  This feed does not require authentication.\n\nFrom a quick look at the feed in the
  web browser, we are going to configure the rest of the parameters:\n\n**Ignore Regex**
  - We are going to need to ignore all the text inside the part enclosed within the
  `#` character (included) \nso we'll configure `^#` as the regular expression to
  use to ignore this text.\n\n**Indicator extraction pattern** - We would like to
  extract the IP range and turn it into a CIDR. For that, we will configure a regular
  expression to extract both IP addresses in the range into 2 groups,\nand transform
  the 2 groups to an IP range. We will then convert the IP range into a CIDR in the
  integration code.\n\nThis would be our extraction pattern object as a JSON string,
  which we will fill in the field in the instance configuration:\n```json\n{\n  \"regex\":
  \"^([0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3})\\\\t([0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3}\\\\.[0-9]{1,3})\",\n
  \ \"transform\": \"\\\\1-\\\\2\"\n}\n```\n\n****Fields extraction pattern**** -
  We want to extract the name and the number of attacks field for each IP range in
  the feed.\nFor each field we will configure a regular expression to extract it and
  then a template to grab the regex group as is.\nThis would be the JSON string we
  use in the integration configuration:\n```json\n{\n  \"number_of_attacks\":\n    {\n
  \       \"regex\": \"^.*\\\\t.*\\\\t[0-9]+\\\\t([0-9]+)\",\n        \"transform\":
  \"\\\\1\"\n    },\n  \"name\":\n     {  \n        \"regex\": \"^.*\\\\t.*\\\\t[0-9]+\\\\t[0-9]+\\\\t([^\\\\t]+)\",\n
  \       \"transform\": \"\\\\1\"\n     }\n}\n```\n\nThen our indicator will have
  these 2 additional fields. We can map them to other indicator fields in the system
  later.\n\n\n**Headers** - No need for additional headers.\n\nNow we have successfully
  configured an instance for the DShield Black List feed, once we enable `Fetches
  indicators` the instance will start pulling indicators.\n\nBy clicking `Mapping`
  in the integration instance, we can map the fields we previously configured to actual
  indicator fields.\nWe can use `Set up a new classification rule` to use actual data
  from the feed.\n\n\n---\n[View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/plain-text-feed)"
display: Plain Text Feed
image: data:image/png;base64,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
name: Plain Text Feed
script:
  commands:
  - arguments:
    - defaultValue: "50"
      description: The maximum number of results to return to the output. The default
        value is 50.
      name: limit
    - description: The indicator type. If the configuration parameter 'Auto detect
        indicator type' is marked true for the integration instance, then this value
        will be ignored.
      name: indicator_type
    description: Gets indicators from the feed.
    name: plaintext-get-indicators
  dockerimage: demisto/py3-tools:1.0.0.75615
  feed: true
  runonce: false
  script: |
    register_module_line('Plain Text Feed', 'start', __line__())
    ### pack version: 1.1.25




    def main():
        params = demisto.params()
        # when auto_detect is not selected
        if params.get('auto_detect_type') is False and not params.get('indicator_type'):
            return_error('Indicator Type cannot be empty when Auto Detect Indicator Type is unchecked')
        # when auto_detect does not exist - for previous integration instances
        if params.get('auto_detect_type') is None and not params.get('indicator_type'):
            return_error('Indicator Type cannot be empty')
        if params.get('indicator_type') == 'Custom':
            custom_indicator_type = params.get('custom_indicator_type')
            if not custom_indicator_type:
                return_error('If custom indicator type has been chosen, an indicator type must be specified.')
            else:
                params.update({'indicator_type': custom_indicator_type})
        feed_main('PlainText', params=params, prefix='plaintext')



    ### GENERATED CODE ###: from HTTPFeedApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('HTTPFeedApiModule', 'start', __line__(), wrapper=-3)




    ''' IMPORTS '''
    import urllib3
    import requests
    from typing import Optional, Pattern, List

    # disable insecure warnings
    urllib3.disable_warnings()

    ''' GLOBALS '''
    TAGS = 'tags'
    TLP_COLOR = 'trafficlightprotocol'
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'


    class Client(BaseClient):
        def __init__(self, url: str, feed_name: str = 'http', insecure: bool = False, credentials: dict = None,
                     ignore_regex: str = None, encoding: str = None, indicator_type: str = '',
                     indicator: str = '', fields: str = '{}', feed_url_to_config: dict = None, polling_timeout: int = 20,
                     headers: dict = None, proxy: bool = False, custom_fields_mapping: dict = None, **kwargs):
            """Implements class for miners of plain text feeds over HTTP.
            **Config parameters**
            :param: url: URL of the feed.
            :param: polling_timeout: timeout of the polling request in seconds.
                Default: 20
            :param feed_name: The name of the feed.
            :param: custom_fields_mapping: Dict, the "fields" to be used in the indicator - where the keys
            are the *current* keys of the fields returned feed data and the *values* are the *indicator fields in Demisto*.
            :param: headers: dict, Optional list of headers to send in the request.
            :param: ignore_regex: Python regular expression for lines that should be
                ignored. Default: *null*
            :param: insecure: boolean, if *false* feed HTTPS server certificate is
                verified. Default: *false*
            :param credentials: username and password used for basic authentication.
                                Can be also used as API key header and value by specifying _header in the username field.
            :param: encoding: encoding of the feed, if not UTF-8. See
                ``str.decode`` for options. Default: *null*, meaning do
                nothing, (Assumes UTF-8).
            :param: indicator_type: Default indicator type
            :param: indicator: an *extraction dictionary* to extract the indicator from
                the line. If *null*, the text until the first whitespace or newline
                character is used as indicator. Default: *null*
            :param: fields: a dictionary of *extraction dictionaries* to extract
                additional attributes from each line. Default: {}
            :param: feed_url_to_config: For each service, a dictionary to process indicators by.
            For example, ASN feed:
            'https://www.spamhaus.org/drop/asndrop.txt': {
                'indicator_type': ASN,
                'indicator': { (Regex to extract the indicator by, if empty - the whole line is extracted)
                    'regex': r'^AS[0-9]+',
                },
                'fields': [{ (See Extraction dictionary below)
                    'asndrop_country': {
                        'regex': '^.*;\\W([a-zA-Z]+)\\W+',
                        'transform: r'\1'
                    }
                }]
            }
            :param: proxy: Use proxy in requests.
            **Extraction dictionary**
                Extraction dictionaries contain the following keys:
                :regex: Python regular expression for searching the text.
                :transform: template to generate the final value from the result
                    of the regular expression. Default: the entire match of the regex
                    is used as extracted value.
                See Python `re <https://docs.python.org/2/library/re.html>`_ module for
                details about Python regular expressions and templates.
            Example:
                Example config in YAML where extraction dictionaries are used to
                extract the indicator and additional fields::
                    url: https://www.dshield.org/block.txt
                    ignore_regex: "[#S].*"
                    indicator:
                        regex: '^([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})\\t([0-9]
                        {1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})'
                        transform: '\\1-\\2'
                    fields:
                        dshield_nattacks:
                            regex: '^.*\\t.*\\t[0-9]+\\t([0-9]+)'
                            transform: '\\1'
                        dshield_name:
                            regex: '^.*\\t.*\\t[0-9]+\\t[0-9]+\\t([^\\t]+)'
                            transform: '\\1'
                        dshield_country:
                            regex: '^.*\\t.*\\t[0-9]+\\t[0-9]+\\t[^\\t]+\\t([A-Z]+)'
                            transform: '\\1'
                        dshield_email:
                            regex: '^.*\\t.*\\t[0-9]+\\t[0-9]+\\t[^\\t]+\\t[A-Z]+\\t(\\S+)'
                            transform: '\\1'
                Example config in YAML where the text in each line until the first
                whitespace is used as indicator::
                    url: https://ransomwaretracker.abuse.ch/downloads/CW_C2_URLBL.txt
                    ignore_regex: '^#'
            """
            super().__init__(base_url=url, verify=not insecure, proxy=proxy)
            handle_proxy()
            try:
                self.polling_timeout = int(polling_timeout)
            except (ValueError, TypeError):
                raise ValueError('Please provide an integer value for "Request Timeout"')

            self.headers = headers
            self.encoding = encoding
            self.feed_name = feed_name
            if not credentials:
                credentials = {}
            self.username = None
            self.password = None

            username = credentials.get('identifier', '')
            if username.startswith('_header:'):
                if not self.headers:
                    self.headers = {}
                header_field = username.split(':')
                if len(header_field) < 2:
                    raise ValueError('An incorrect value was provided for an API key header.'
                                     ' The correct value is "_header:<header_name>"')
                header_name: str = header_field[1]
                header_value: str = credentials.get('password', '')
                self.headers[header_name] = header_value
            else:
                self.username = username
                self.password = credentials.get('password', None)

            self.indicator_type = indicator_type
            if feed_url_to_config:
                self.feed_url_to_config = feed_url_to_config
            else:
                self.feed_url_to_config = {url: self.get_feed_config(fields, indicator)}
            self.ignore_regex: Optional[Pattern] = None
            if ignore_regex is not None:
                self.ignore_regex = re.compile(ignore_regex)

            if custom_fields_mapping is None:
                custom_fields_mapping = {}
            self.custom_fields_mapping = custom_fields_mapping

        def get_feed_config(self, fields_json: str = '', indicator_json: str = ''):
            """
            Get the feed configuration from the indicator and field JSON strings.
            :param fields_json: JSON string of fields to extract, for example:
                {
                    'fieldname': {
                        'regex': regex,
                        'transform': r'\1'
                    }
                },
                {
                    'asndrop_org': {
                        'regex': regex,
                        'transform': r'\1'
                    }
                }
            :param indicator_json: JSON string of the indicator to extract, for example:
                {'regex': regex}
            :return: The feed configuration.
            """
            config = {}
            if indicator_json:
                indicator = json.loads(indicator_json)
                if 'regex' in indicator:
                    indicator['regex'] = re.compile(indicator['regex'])
                else:
                    raise ValueError(f'{self.feed_name} - indicator stanza should have a regex')
                if 'transform' not in indicator:
                    if indicator['regex'].groups > 0:
                        LOG(f'{self.feed_name} - no transform string for indicator but pattern contains groups')
                    indicator['transform'] = r'\g<0>'

                config['indicator'] = indicator
            if fields_json:
                fields = json.loads(fields_json)
                config['fields'] = []
                for f, fattrs in fields.items():
                    if 'regex' in fattrs:
                        fattrs['regex'] = re.compile(fattrs['regex'])
                    else:
                        raise ValueError(f'{self.feed_name} - {f} field does not have a regex')
                    if 'transform' not in fattrs:
                        if fattrs['regex'].groups > 0:
                            LOG(f'{self.feed_name} - no transform string for field {f} but pattern contains groups')
                        fattrs['transform'] = r'\g<0>'
                    config['fields'].append({
                        f: fattrs
                    })

            return config

        def build_iterator(self, **kwargs):
            """
            For each URL (service), send an HTTP request to get indicators and return them after filtering by Regex
            :param kwargs: Arguments to send to the HTTP API endpoint
            :return: List of indicators
            """
            kwargs['stream'] = True
            kwargs['verify'] = self._verify
            kwargs['timeout'] = self.polling_timeout

            if self.headers is not None:
                kwargs['headers'] = self.headers

            if self.username is not None and self.password is not None:
                kwargs['auth'] = (self.username, self.password)
            try:
                urls = self._base_url
                url_to_response_list: List[dict] = []
                if not isinstance(urls, list):
                    urls = [urls]
                for url in urls:
                    if is_demisto_version_ge('6.5.0'):
                        # Set the If-None-Match and If-Modified-Since headers if we have etag or
                        # last_modified values in the context, for server version higher than 6.5.0.
                        last_run = demisto.getLastRun()
                        etag = last_run.get(url, {}).get('etag')
                        last_modified = last_run.get(url, {}).get('last_modified')
                        if etag:
                            if not kwargs.get('headers'):
                                kwargs['headers'] = {}
                            kwargs['headers']['If-None-Match'] = etag

                        if last_modified:
                            if not kwargs.get('headers'):
                                kwargs['headers'] = {}
                            kwargs['headers']['If-Modified-Since'] = last_modified

                    r = requests.get(
                        url,
                        **kwargs
                    )
                    try:
                        r.raise_for_status()
                    except Exception:
                        LOG(f'{self.feed_name!r} - exception in request:'
                            f' {r.status_code!r} {r.content!r}')
                        raise
                    no_update = get_no_update_value(r, url) if is_demisto_version_ge('6.5.0') else True
                    url_to_response_list.append({url: {'response': r, 'no_update': no_update}})
            except requests.exceptions.ConnectTimeout as exception:
                err_msg = 'Connection Timeout Error - potential reasons might be that the Server URL parameter' \
                          ' is incorrect or that the Server is not accessible from your host.'
                raise DemistoException(err_msg, exception)
            except requests.exceptions.SSLError as exception:
                # in case the "Trust any certificate" is already checked
                if not self._verify:
                    raise
                err_msg = 'SSL Certificate Verification Failed - try selecting \'Trust any certificate\' checkbox in' \
                          ' the integration configuration.'
                raise DemistoException(err_msg, exception)
            except requests.exceptions.ProxyError as exception:
                err_msg = 'Proxy Error - if the \'Use system proxy\' checkbox in the integration configuration is' \
                          ' selected, try clearing the checkbox.'
                raise DemistoException(err_msg, exception)
            except requests.exceptions.ConnectionError as exception:
                # Get originating Exception in Exception chain
                error_class = str(exception.__class__)
                err_type = '<' + error_class[error_class.find('\'') + 1: error_class.rfind('\'')] + '>'
                err_msg = 'Verify that the server URL parameter' \
                          ' is correct and that you have access to the server from your host.' \
                          '\nError Type: {}\nError Number: [{}]\nMessage: {}\n' \
                    .format(err_type, exception.errno, exception.strerror)
                raise DemistoException(err_msg, exception)

            results = []
            for url_to_response in url_to_response_list:
                for url, res_data in url_to_response.items():
                    lines = res_data.get('response')
                    result = lines.iter_lines()
                    if self.encoding is not None:
                        result = map(
                            lambda x: x.decode(self.encoding).encode('utf_8'),
                            result
                        )
                    else:
                        result = map(
                            lambda x: x.decode('utf_8'),
                            result
                        )
                    if self.ignore_regex is not None:
                        result = filter(
                            lambda x: self.ignore_regex.match(x) is None,  # type: ignore[union-attr, arg-type]
                            result
                        )
                    results.append({url: {'result': result, 'no_update': res_data.get('no_update')}})
            return results

        def custom_fields_creator(self, attributes: dict):
            created_custom_fields = {}
            for attribute in attributes.keys():
                if attribute in self.custom_fields_mapping.keys() or attribute in [TAGS, TLP_COLOR]:
                    if attribute in [TAGS, TLP_COLOR]:
                        created_custom_fields[attribute] = attributes[attribute]
                    else:
                        created_custom_fields[self.custom_fields_mapping[attribute]] = attributes[attribute]

            return created_custom_fields


    def get_no_update_value(response: requests.Response, url: str) -> bool:
        """
        detect if the feed response has been modified according to the headers etag and last_modified.
        For more information, see this:
        https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified
        https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag
        Args:
            response: (requests.Response) The feed response.
            url: (str) The feed URL (service).
        Returns:
            boolean with the value for noUpdate argument.
            The value should be False if the response was modified.
        """
        if response.status_code == 304:
            demisto.debug('No new indicators fetched, createIndicators will be executed with noUpdate=True.')
            return True

        etag = response.headers.get('ETag')
        last_modified = response.headers.get('Last-Modified')

        if not etag and not last_modified:
            demisto.debug('Last-Modified and Etag headers are not exists,'
                          'createIndicators will be executed with noUpdate=False.')
            return False

        last_run = demisto.getLastRun()
        last_run[url] = {'last_modified': last_modified, 'etag': etag}
        demisto.setLastRun(last_run)

        demisto.debug('New indicators fetched - the Last-Modified value has been updated,'
                      ' createIndicators will be executed with noUpdate=False.')
        return False


    def datestring_to_server_format(date_string: str) -> str:
        """
        formats a datestring to the ISO-8601 format which the server expects to recieve
        :param date_string: Date represented as a tring
        :return: ISO-8601 date string
        """
        parsed_date = dateparser.parse(date_string, settings={'TIMEZONE': 'UTC'})
        return parsed_date.strftime(DATE_FORMAT)    # type: ignore


    def get_indicator_fields(line, url, feed_tags: list, tlp_color: Optional[str], client: Client):
        """
        Extract indicators according to the feed type
        :param line: The current line in the feed
        :param url: The feed URL
        :param client: The client
        :param feed_tags: The indicator tags.
        :param tlp_color: Traffic Light Protocol color.
        :return: The indicator
        """
        attributes = None
        value: str = ''
        indicator = None
        fields_to_extract = []
        feed_config = client.feed_url_to_config.get(url, {})
        if feed_config:
            if 'indicator' in feed_config:
                indicator = feed_config['indicator']
                if 'regex' in indicator:
                    indicator['regex'] = re.compile(indicator['regex'])
                if 'transform' not in indicator:
                    indicator['transform'] = r'\g<0>'

        if 'fields' in feed_config:
            fields = feed_config['fields']
            for field in fields:
                for f, fattrs in field.items():
                    field = {f: {}}
                    if 'regex' in fattrs:
                        field[f]['regex'] = re.compile(fattrs['regex'])
                    if 'transform' not in fattrs:
                        field[f]['transform'] = r'\g<0>'
                    else:
                        field[f]['transform'] = fattrs['transform']
                    fields_to_extract.append(field)

        line = line.strip()
        if line:
            extracted_indicator = line.split()[0]
            if indicator:
                extracted_indicator = indicator['regex'].search(line)
                if extracted_indicator is None:
                    return attributes, value
                if 'transform' in indicator:
                    extracted_indicator = extracted_indicator.expand(indicator['transform'])
            attributes = {}
            for field in fields_to_extract:
                for f, fattrs in field.items():
                    m = fattrs['regex'].search(line)

                    if m is None:
                        continue

                    attributes[f] = m.expand(fattrs['transform'])

                    try:
                        i = int(attributes[f])
                    except Exception:
                        pass
                    else:
                        attributes[f] = i
            attributes['value'] = value = extracted_indicator
            attributes['type'] = feed_config.get('indicator_type', client.indicator_type)
            attributes['tags'] = feed_tags

            if tlp_color:
                attributes['trafficlightprotocol'] = tlp_color

        return attributes, value


    def fetch_indicators_command(client, feed_tags, tlp_color, itype, auto_detect, create_relationships=False, **kwargs):
        iterators = client.build_iterator(**kwargs)
        indicators = []

        # set noUpdate flag in createIndicators command True only when all the results from all the urls are True.
        no_update = all([next(iter(iterator.values())).get('no_update', False) for iterator in iterators])

        for iterator in iterators:
            for url, lines in iterator.items():
                for line in lines.get('result', []):
                    attributes, value = get_indicator_fields(line, url, feed_tags, tlp_color, client)
                    if value:
                        if 'lastseenbysource' in attributes.keys():
                            attributes['lastseenbysource'] = datestring_to_server_format(attributes['lastseenbysource'])

                        if 'firstseenbysource' in attributes.keys():
                            attributes['firstseenbysource'] = datestring_to_server_format(attributes['firstseenbysource'])
                        indicator_type = determine_indicator_type(
                            client.feed_url_to_config.get(url, {}).get('indicator_type'), itype, auto_detect, value)
                        indicator_data = {
                            "value": value,
                            "type": indicator_type,
                            "rawJSON": attributes,
                        }
                        if create_relationships and client.feed_url_to_config.get(url, {}).get('relationship_name'):
                            if attributes.get('relationship_entity_b'):
                                relationships_lst = EntityRelationship(
                                    name=client.feed_url_to_config.get(url, {}).get('relationship_name'),
                                    entity_a=value,
                                    entity_a_type=indicator_type,
                                    entity_b=attributes.get('relationship_entity_b'),
                                    entity_b_type=FeedIndicatorType.indicator_type_by_server_version(
                                        client.feed_url_to_config.get(url, {}).get('relationship_entity_b_type')),
                                )
                                relationships_of_indicator = [relationships_lst.to_indicator()]
                                indicator_data['relationships'] = relationships_of_indicator

                        if len(client.custom_fields_mapping.keys()) > 0 or TAGS in attributes.keys():
                            custom_fields = client.custom_fields_creator(attributes)
                            indicator_data["fields"] = custom_fields

                        indicators.append(indicator_data)
        return indicators, no_update


    def determine_indicator_type(indicator_type, default_indicator_type, auto_detect, value):
        """
        Detect the indicator type of the given value.
        Args:
            indicator_type: (str) Indicator type given in the config.
            default_indicator_type: Indicator type which was inserted as a param of the integration by user.
            auto_detect: (bool) True whether auto detection of the indicator type is wanted.
            value: (str) The value which we'd like to get indicator type of.
        Returns:
            Str which stands for the indicator type after detection.
        """
        if auto_detect:
            indicator_type = auto_detect_indicator_type(value)
        if not indicator_type:
            indicator_type = default_indicator_type
        return indicator_type


    def get_indicators_command(client: Client, args):
        itype = args.get('indicator_type', client.indicator_type)
        limit = int(args.get('limit'))
        feed_tags = args.get('feedTags')
        tlp_color = args.get('tlp_color')
        auto_detect = demisto.params().get('auto_detect_type')
        create_relationships = demisto.params().get('create_relationships')
        indicators_list, _ = fetch_indicators_command(client, feed_tags, tlp_color, itype, auto_detect, create_relationships)[:limit]
        entry_result = camelize(indicators_list)
        hr = tableToMarkdown('Indicators', entry_result, headers=['Value', 'Type', 'Rawjson'])
        return hr, {}, indicators_list


    def test_module(client: Client, args):
        if not client.feed_url_to_config:
            indicator_type = args.get('indicator_type', demisto.params().get('indicator_type'))
            if not FeedIndicatorType.is_valid_type(indicator_type):
                indicator_types = []
                for key, val in vars(FeedIndicatorType).items():
                    if not key.startswith('__') and type(val) == str:
                        indicator_types.append(val)
                supported_values = ', '.join(indicator_types)
                raise ValueError(f'Indicator type of {indicator_type} is not supported. Supported values are:'
                                 f' {supported_values}')
        client.build_iterator()
        return 'ok', {}, {}


    def feed_main(feed_name, params=None, prefix=''):
        if not params:
            params = assign_params(**demisto.params())
        if 'feed_name' not in params:
            params['feed_name'] = feed_name
        feed_tags = argToList(demisto.params().get('feedTags'))
        tlp_color = demisto.params().get('tlp_color')
        client = Client(**params)
        command = demisto.command()
        if command != 'fetch-indicators':
            demisto.info('Command being called is {}'.format(command))
        if prefix and not prefix.endswith('-'):
            prefix += '-'
        # Switch case
        commands: dict = {
            'test-module': test_module,
            f'{prefix}get-indicators': get_indicators_command
        }
        try:
            if command == 'fetch-indicators':
                indicators, no_update = fetch_indicators_command(client, feed_tags, tlp_color,
                                                                 params.get('indicator_type'),
                                                                 params.get('auto_detect_type'),
                                                                 params.get('create_relationships'))

                # check if the version is higher than 6.5.0 so we can use noUpdate parameter
                if is_demisto_version_ge('6.5.0'):
                    if not indicators:
                        demisto.createIndicators(indicators, noUpdate=no_update)  # type: ignore
                    else:
                        # we submit the indicators in batches
                        for b in batch(indicators, batch_size=2000):
                            demisto.createIndicators(b, noUpdate=no_update)  # type: ignore
                else:
                    # call createIndicators without noUpdate arg
                    if not indicators:
                        demisto.createIndicators(indicators)  # type: ignore
                    else:
                        for b in batch(indicators, batch_size=2000):  # type: ignore
                            demisto.createIndicators(b)

            else:
                args = demisto.args()
                args['feed_name'] = feed_name
                if feed_tags:
                    args['feedTags'] = feed_tags
                if tlp_color:
                    args['tlp_color'] = tlp_color
                readable_output, outputs, raw_response = commands[command](client, args)
                return_outputs(readable_output, outputs, raw_response)
        except Exception as e:
            err_msg = f'Error in {feed_name} integration [{e}]'
            return_error(err_msg, error=e)

    register_module_line('HTTPFeedApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    if __name__ in ('__builtin__', 'builtins'):
        main()

    register_module_line('Plain Text Feed', 'end', __line__())
  subtype: python3
  type: python
system: true
