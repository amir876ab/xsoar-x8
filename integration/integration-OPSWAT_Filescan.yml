category: Forensics & Malware Analysis
commonfields:
  id: OPSWAT Filescan
  version: -1
configuration:
- defaultvalue: https://www.filescan.io/api
  display: Server URL (e.g. https://www.filescan.io/api)
  name: url
  required: true
  type: 0
- additionalinfo: The API Key to use for connection
  display: ""
  displaypassword: API Key
  hiddenusername: true
  name: api_key
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 6.0.0
    itemVersion: 1.0.2
    packID: OPSWAT-Filescan
    packName: OPSWAT Filescan Sandbox
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Unique adaptive threat analysis technology, enabling zero-day malware
  detection and more Indicator of Compromise (IOCs) extraction.
detaileddescription: |-
  ### Partner Contributed Integration
  #### Integration Author: OPSWAT
  Support and maintenance for this integration are provided by the author. Please use the following contact details:
  - **Email**: [threatintel@opswat.com](mailto:threatintel@opswat.com)
  - **URL**: [https://docs.opswat.com/filescan](https://docs.opswat.com/filescan)
  ***
  ## Prerequisites

  For the integration you need your OPSWAT Filescan Sandbox API key.

  You can generate it if you don't have one after logging in on the [Filescan Sandbox](https://www.filescan.io/users/profile) page under the My settings - API Key tab.

  Copy the API key and insert it to the *API Key* field.

  Notice: Submitting indicators using the ***opswat-filescan-scan-url*** command of this integration might make the indicator data publicly available.  See the vendorâ€™s documentation for more details.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/opswat-filescan)
display: OPSWAT Filescan Sandbox (Partner Contribution)
image: data:image/png;base64,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
name: OPSWAT Filescan
script:
  commands:
  - arguments:
    - deprecated: true
      description: The flow ID what needs to poll
      name: flow_id
    - default: true
      description: The URL to submit.
      name: url
      required: true
    - defaultValue: "600"
      description: The timeout for the polling in seconds.
      name: timeout
    - deprecated: true
      description: Hide polling output.
      name: hide_polling_output
    - description: Uploaded file/url description
      name: description
    - description: Tags array to propagate
      name: tags
    - description: Custom password, in case uploaded archive is protected
      name: password
      secret: true
    - description: If file should not be available for download by other users
      name: is_private
    description: Scan URL resource.
    name: opswat-filescan-scan-url
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: File.Name
      description: The full file name (including file extension).
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.Malicious.Vendor
      description: The vendor that reported the file as malicious.
      type: String
    - contextPath: OPSWAT.Filescan.Submission.flow_id
      description: The flow ID.
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.finalVerdict.verdict
      description: The final verdict
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.allTags
      description: All tags
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.overallState
      description: Overall state of the scan
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.name
      description: Name of the main scan task
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.additionalInfo
      description: Additional informations about the main scan task
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.ID
      description: ID of the main scan task
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.state
      description: State of the main scan task
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.resourceReference
      description: Resource reference of the main scan task
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.opcount
      description: Counter
      type: Number
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.processTime
      description: processTime
      type: Number
    - contextPath: OPSWAT.Filescan.Analysis.subtaskReferences
      description: Status of scan subtasks
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.allSignalGroups
      description: All signal groups
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.resources
      description: Resources
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.file.name
      description: The name of the file
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.hash
      description: The SHA256 of the file
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.type
      description: The type of the submission
      type: String
    polling: true
  - arguments:
    - deprecated: true
      description: The flow ID what needs to poll
      name: flow_id
    - description: The War Room entry ID of the file to submit.
      name: entry_id
      required: true
    - defaultValue: "1200"
      description: The timeout for the polling in seconds.
      name: timeout
    - deprecated: true
      description: Hide polling output.
      name: hide_polling_output
    - description: Uploaded file/url description
      name: description
    - description: Tags array to propagate
      name: tags
    - description: Custom password, in case uploaded archive is protected
      name: password
      secret: true
    - description: If file should not be available for download by other users
      name: is_private
    description: Scan file resource.
    name: opswat-filescan-scan-file
    outputs:
    - contextPath: DBotScore.Indicator
      description: The indicator that was tested.
      type: String
    - contextPath: DBotScore.Type
      description: The indicator type.
      type: String
    - contextPath: DBotScore.Vendor
      description: The vendor used to calculate the score.
      type: String
    - contextPath: DBotScore.Score
      description: The actual score.
      type: Number
    - contextPath: File.Name
      description: The full file name (including file extension).
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.Malicious.Vendor
      description: The vendor that reported the file as malicious.
      type: String
    - contextPath: OPSWAT.Filescan.Submission.flow_id
      description: The flow ID.
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.finalVerdict.verdict
      description: The final verdict
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.allTags
      description: All tags
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.overallState
      description: Overall state of the scan
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.name
      description: Name of the main scan task
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.additionalInfo
      description: Additional informations about the main scan task
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.ID
      description: ID of the main scan task
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.state
      description: State of the main scan task
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.resourceReference
      description: Resource reference of the main scan task
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.opcount
      description: Counter
      type: Number
    - contextPath: OPSWAT.Filescan.Analysis.taskReference.processTime
      description: processTime
      type: Number
    - contextPath: OPSWAT.Filescan.Analysis.subtaskReferences
      description: Status of scan subtasks
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.allSignalGroups
      description: All signal groups
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.resources
      description: Resources
      type: Unknown
    - contextPath: OPSWAT.Filescan.Analysis.file.name
      description: The name of the file
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.hash
      description: The SHA256 of the file
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.type
      description: The type of the submission
      type: String
    polling: true
  - arguments:
    - default: true
      description: The query string
      name: query
      required: true
    - description: Page number, starting from 1
      name: page
    - auto: PREDEFINED
      description: Page size. Can be 5, 10 or 20
      name: page_size
      predefined:
      - "5"
      - "10"
      - "20"
    - description: Number of total results. Maximum 50. (If page and page_size was
        also provided, then it will be ignored.)
      name: limit
    description: Search for reports. Finds reports and uploaded files by various tokens.
    name: opswat-filescan-search-query
    outputs:
    - contextPath: OPSWAT.Filescan.Analysis.id
      description: The analysis id
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.name
      description: The file name.
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.sha256
      description: The file SHA256
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.verdict
      description: The scan verdict
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.state
      description: The scan state. Eg. success, failed
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.date
      description: The scan date
      type: Date
    - contextPath: OPSWAT.Filescan.Analysis.file.mime_type
      description: The file MimeType
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.file.short_type
      description: The type of the submission
      type: String
    - contextPath: OPSWAT.Filescan.Analysis.tags
      description: Tags
      type: Unknown
  dockerimage: demisto/python3:3.10.12.63474
  runonce: false
  script: |
    register_module_line('OPSWAT Filescan', 'start', __line__())
    ### pack version: 1.0.2



    """ IMPORTS """
    from typing import Any
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()

    """GLOBALS/PARAMS """
    INTEGRATION_NAME = "OPSWAT Filescan Sandbox Integration"
    INTEGRATION_CONTEXT_NAME = "OPSWAT.Filescan"


    class Client(BaseClient):
        def __init__(self, api_key: str, base_url: str, proxy: bool, verify: bool):
            super().__init__(base_url=base_url, proxy=proxy, verify=verify)
            self.api_key = api_key

            if self.api_key:
                self._headers = {"X-Api-Key": self.api_key}

        def test_module(self) -> dict:
            """
            Return information about the user. (Need API key)
            """
            request_result = self._http_request(
                method="GET",
                ok_codes=([200]),
                url_suffix="/users/me",
            )
            return request_result

        def post_sample(self, args: dict[str, Any]) -> dict[str, Any]:
            data = {}

            if description := args.get("description"):
                data["description"] = description
            if tags := args.get("tags"):
                data["tags"] = tags
            if password := args.get("password"):
                data["password"] = password
            if is_private := args.get("is_private"):
                data["is_private"] = is_private

            if url := args.get("url"):
                data["url"] = url

                return self._http_request(
                    method="POST", url_suffix="/scan/url", ok_codes=([200]), data=data
                )

            elif entry_id := args.get("entry_id"):
                try:
                    file_entry = demisto.getFilePath(entry_id)
                except Exception as e:
                    raise DemistoException(
                        f'Failed to find file entry with id:"{entry_id}". got error: {e}'
                    )

                with open(file_entry["path"], "rb") as file:
                    return self._http_request(
                        method="POST",
                        url_suffix="/scan/file",
                        ok_codes=([200]),
                        data=data,
                        files={"file": file},
                    )
            else:
                raise DemistoException("No file or URL was provided.")

        def get_scan_result(self, flow_id: str) -> dict[str, Any]:

            filters = [
                "filter=general",
                "filter=finalVerdict",
                "filter=allTags",
                "filter=overallState",
                "filter=taskReference",
                "filter=subtaskReferences",
                "filter=allSignalGroups",
            ]

            postfix = "&".join(filters)

            url_suffix = f"/scan/{flow_id}/report?{postfix}"

            response = self._http_request(
                method="GET",
                ok_codes=([200]),
                url_suffix=url_suffix,
            )

            return response

        def get_search_query(self, query_string: str, page: int, page_size: int) -> dict[str, Any]:
            return self._http_request(
                method="GET",
                ok_codes=([200]),
                params={"query": query_string, "page_size": page_size, "page": page},
                url_suffix="/reports/search",
            )


    """ HELPER FUNCTIONS """


    def build_one_reputation_result(report: dict[str, Any]):
        score = Common.DBotScore.NONE

        final_verdict = report.get("finalVerdict", {})
        verdict = final_verdict.get("verdict")
        if verdict.upper() == "BENIGN" or verdict.upper() == "INFORMATIONAL":
            score = Common.DBotScore.GOOD
        elif verdict.upper() == "MALICIOUS" or verdict.upper() == "LIKELY_MALICIOUS":
            score = Common.DBotScore.BAD
        elif verdict.upper() == "SUSPICIOUS":
            score = Common.DBotScore.SUSPICIOUS

        report_file = report.get("file", {})
        report_hash = report_file.get("hash", None)

        dbot_score = Common.DBotScore(
            indicator=report_hash,
            indicator_type=DBotScoreType.FILE,
            integration_name="OPSWAT Filescan Sandbox",
            score=score,
        )

        file = Common.File(
            name=report_file.get("name"), sha256=report_hash, dbot_score=dbot_score
        )

        tags = [tag.get("tag", {}).get("name") for tag in report.get("allTags", [])]
        subtasks = [subtask.get("name") for subtask in report.get("subtaskReferences", [])]
        human_readable = {
            "FileName": report_file.get("name"),
            "FileHash": report_hash,
            "FileType": report_file.get("type"),
            "FinalVerdict": report.get("finalVerdict", {}).get("verdict"),
            "Tags": tags,
            "SubtaskReferences": subtasks,
        }
        readable_output = tableToMarkdown("Scan Result (digest):", human_readable)

        results = CommandResults(
            outputs_prefix=f"{INTEGRATION_CONTEXT_NAME}.Analysis",
            outputs_key_field="sha256",
            outputs=report,
            raw_response=report,
            readable_output=readable_output,
            indicator=file,
        )
        return results


    def build_serach_query_result(analyses: list[dict]) -> CommandResults:
        def build_analysis_hr(analysis: dict[str, Any]) -> dict[str, Any]:
            file_result = analysis.get("file", {})
            hr_analysis = {
                "Id": analysis.get("id"),
                "SampleName": file_result.get("name"),
                "SHA256": file_result.get("sha256"),
                "Verdict": analysis.get("verdict"),
                "State": analysis.get("state"),
                "Date": analysis.get("date"),
                "MIMEType": file_result.get("mime_type"),
                "Type": file_result.get("short_type"),
                "Tags": analysis.get("tags"),
            }
            return hr_analysis

        def build_indicator_object(analysis: dict[str, Any]):
            score = Common.DBotScore.NONE

            verdict = analysis.get("verdict", "UNKNOWN")
            if verdict.upper() == "BENIGN" or verdict.upper() == "INFORMATIONAL":
                score = Common.DBotScore.GOOD
            elif verdict.upper() == "MALICIOUS" or verdict.upper() == "LIKELY_MALICIOUS":
                score = Common.DBotScore.BAD
            elif verdict.upper() == "SUSPICIOUS":
                score = Common.DBotScore.SUSPICIOUS

            analysis_file = analysis.get("file", {})
            dbot_score = Common.DBotScore(
                indicator=analysis_file.get("sha256"),
                indicator_type=DBotScoreType.FILE,
                integration_name="OPSWAT Filescan Sandbox",
                score=score,
            )

            file = Common.File(
                name=analysis_file.get("name"),
                sha256=analysis_file.get("sha256"),
                dbot_score=dbot_score,
            )

            results = CommandResults(
                outputs_prefix=f"{INTEGRATION_CONTEXT_NAME}.Analysis",
                outputs_key_field="sha256",
                indicator=file,
            )
            return results

        hr_headers = [
            "Id",
            "SampleName",
            "SHA256",
            "Verdict",
            "State",
            "Date",
            "MIMEType",
            "Type",
            "Tags",
        ]

        hr_analysis_ls = []

        for analysis in analyses:
            hr_analysis_ls.append(build_analysis_hr(analysis))

        command_result = CommandResults(
            outputs=analyses,
            readable_output=tableToMarkdown("Analysis Result:", hr_analysis_ls, hr_headers),
            outputs_prefix=f"{INTEGRATION_CONTEXT_NAME}.Analysis",
        )

        return command_result


    def sample_submission(client: Client, args: dict[str, Any]) -> PollResult:
        res = client.post_sample(args)
        partial_res = CommandResults(
            readable_output=f'Waiting for submission "{res.get("flow_id")}" to finish...'
        )
        return PollResult(
            response=CommandResults(
                outputs=res,
                outputs_prefix=f"{INTEGRATION_CONTEXT_NAME}.Submission",
                outputs_key_field="flow_id",
            ),
            args_for_next_run={"flow_id": res.get("flow_id"), **args},
            continue_to_poll=True,
            partial_result=partial_res,
        )


    def build_reputation_result(api_reponse: dict[str, Any]):
        reports = api_reponse.get("reports", [])
        command_res_ls = []
        for report in reports:
            command_res_ls.append(build_one_reputation_result(reports[report]))
        return command_res_ls


    def is_valid_pass(api_response: dict[str, Any]):
        if "rejected_files" not in api_response:
            return True
        return all(reject.get("rejected_reason") != "INVALID_PASSWORD" for reject in api_response["rejected_files"])


    @polling_function(
        name=demisto.command(),
        timeout=arg_to_number(demisto.args().get("timeout", 600)),
        interval=1,
        poll_message="Polling result",
        requires_polling_arg=False,
    )
    def polling_submit_command(args: dict[str, Any], client: Client):

        if flow_id := args.get("flow_id"):
            api_response = client.get_scan_result(flow_id)
            successful_response = False

            if api_response.get("allFinished", False):
                successful_response = True

            if successful_response:
                if not is_valid_pass(api_response):
                    raise DemistoException("Invalid password!")

                return PollResult(
                    response=build_reputation_result(api_response), continue_to_poll=False
                )

            return PollResult(
                response=[
                    CommandResults(
                        outputs=api_response,
                        outputs_prefix=f"{INTEGRATION_CONTEXT_NAME}.Submission",
                        outputs_key_field="flow_id",
                        readable_output=f'Waiting for submission "{api_response.get("flow_id")}" to finish...',
                    ),
                ],
                continue_to_poll=True,
                args_for_next_run={"flow_id": args.get("flow_id"), **args},
            )
        else:
            return sample_submission(client, args)


    """ COMMANDS """


    def test_module_command(client: Client, *_) -> str:
        """Performs a basic GET request to check if the API is reachable and authentication is successful."""
        results = client.test_module()
        if "accountId" in results:
            return "ok"
        raise DemistoException(f"\nTest module failed, {results}")


    def scan_command(client: Client, args: dict[str, Any]):
        return polling_submit_command(args=args, client=client)


    def search_query_command(client: Client, args: dict[str, Any]):
        def validate_args():
            if page_size and page_size not in [5, 10, 20]:
                raise DemistoException("Page size value must be 5, 10 or 20")
            if page and page <= 0:
                raise DemistoException("Page must be an integer and grater than 0")
            if limit and (limit <= 0 or limit > 50):
                raise DemistoException("Limit must be an integer and between 1 and 50")

        items = []
        query_string = args.get("query", "")
        page_size = arg_to_number(args.get("page_size"))
        page = arg_to_number(args.get("page"))
        limit = arg_to_number(args.get("limit")) or 10

        validate_args()

        if page_size and not page:
            page = 1
        elif not page_size and page:
            page_size = 10

        if page_size and page:
            items = client.get_search_query(query_string, page, page_size).get("items", [])
        else:
            page_size = 20
            page = 1
            continue_query = True
            while continue_query:
                response = client.get_search_query(query_string, page, page_size)
                actual_items = response.get("items", [])
                total_available_items = response.get("count", len(items))
                # queried all or reached the limit
                if total_available_items == len(items) or len(items) >= limit:
                    continue_query = False
                items += actual_items
                page += 1
            items = items[0:limit]

        if items:
            return build_serach_query_result(items)
        return CommandResults(readable_output="No Results were found.")


    """ COMMANDS MANAGER / SWITCH PANEL """


    def main():

        params = demisto.params()
        base_url = params.get("url", "")
        api_key = params.get('api_key', {}).get('password')
        verify = not params.get("insecure", False)
        proxy = params.get("proxy", False)

        command = demisto.command()
        demisto.info(f"Command being called is {command}")
        args = demisto.args()

        try:
            client = Client(api_key=api_key, base_url=base_url, verify=verify, proxy=proxy)
            handle_proxy()

            if command == "test-module":
                return_results(test_module_command(client))
            elif command == "opswat-filescan-scan-url":
                return_results(scan_command(client, args))
            elif command == "opswat-filescan-scan-file":
                return_results(scan_command(client, args))
            elif command == "opswat-filescan-search-query":
                return_results(search_query_command(client, args))
            else:
                raise NotImplementedError(f"{command} command is not implemented.")
        except Exception as e:
            err_msg = f"Exception in {INTEGRATION_NAME} : Failed to execute {command} command: [{e!r}]"
            return_error(err_msg, error=e)


    """ ENTRY POINT """
    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('OPSWAT Filescan', 'end', __line__())
  subtype: python3
  type: python
system: true
