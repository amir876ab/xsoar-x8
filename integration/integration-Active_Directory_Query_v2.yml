category: Authentication & Identity Management
commonfields:
  id: Active Directory Query v2
  version: -1
configuration:
- display: Server IP address (for example, 192.168.0.1)
  name: server_ip
  required: true
  section: Connect
  type: 0
- advanced: true
  display: Port. If not specified, the default port is 389, or 636 for LDAPS.
  name: port
  required: false
  section: Connect
  type: 0
- display: Username
  displaypassword: Password
  name: credentials
  required: true
  section: Connect
  type: 9
- advanced: true
  display: NTLM authentication
  name: ntlm
  required: false
  section: Connect
  type: 8
- display: Base DN (for example "dc=company,dc=com")
  name: base_dn
  required: true
  section: Connect
  type: 0
- defaultvalue: "500"
  display: Page size
  name: page_size
  required: true
  section: Collect
  type: 0
- defaultvalue: SSL
  display: Secure Connection
  name: secure_connection
  options:
  - None
  - SSL
  - TLS
  - Start TLS
  required: true
  section: Connect
  type: 15
- additionalinfo: The SSL\TLS version to use in SSL or Start TLS connections types.
    Default is None. It is recommended to select the TLS_CLIENT option, which auto-negotiate
    the highest protocol version that both the client and server support, and configure
    the context client-side connections.
  advanced: true
  defaultvalue: None
  display: SSL Version
  name: ssl_version
  options:
  - None
  - TLS
  - TLSv1
  - TLSv1_1
  - TLSv1_2
  - TLS_CLIENT
  required: false
  section: Connect
  type: 15
- advanced: true
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  section: Connect
  type: 8
- additionalinfo: Used in the IAM commands.
  defaultvalue: User Profile - Active Directory (Incoming)
  display: Incoming Mapper
  name: mapper-in
  required: true
  section: Connect
  type: 0
- additionalinfo: Used in the IAM commands.
  defaultvalue: User Profile - Active Directory (Outgoing)
  display: Outgoing Mapper
  name: mapper-out
  required: true
  section: Connect
  type: 0
- display: Group CN for terminated employees
  name: group-cn
  required: false
  section: Connect
  type: 0
- additionalinfo: If true, the user is created if the user profile doesn't exist in
    AD. Used in IAM commands only.
  advanced: true
  defaultvalue: "true"
  display: Create user if does not exist
  name: create-if-not-exists
  required: false
  section: Connect
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.6.25
    packID: Active_Directory_Query
    packName: Active Directory Query
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: The Active Directory Query integration enables you to access and manage
  Active Directory objects (users, contacts, and computers).
detaileddescription: |-
  Active Directory search uses paging. You set the page size by specifying the 'page size' parameter in the instance settings.



  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/active-directory-query-v2)
display: Active Directory Query v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAAXNSR0IArs4c6QAADQlJREFUeAHtWntwVcUZ/3b3nPvIzTsBAiS5yU3iA5xSReuzijiKMmr1n3TaCiSAo1UHtdqx9XnVobZD1QrFNhJuQoJTSR/DVKF26IxiR8UWrVpw0CT35gUIIZDHTXLvPWd3++1JbriJNyFWkKhnZ849e/Z8u/vt7/ft7rffuQB2shGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBE47QiQ06GBBKB/a2zUfx/KzGnXU2YVGF0H/npN4YHTocvXvU/tVA1Qkfju7t1sdVd+Vjulswc4LeyXrCQqaek0QopjnxAvB5hBqTOrjMdWox6PnCpdvsntfiGCFYnw2muU7FwgbrqiO71R6heGY7w0xuEMJNFnHCJek5AZ3IAcoTuYYBpIICClQMyRXsnBQRhIIb+QHt9kAk809hMCiyQS8C9gP7pqU9onRtb0cMTwxijxRQQtzQXmk9zp+/6loep/R3KCBx2ebQaTINkwiQJJFAIIQUINA3VRl2owIUmknCLvdjolCCQlWJF61qtHbuyl7u/kmKJMSOEze1meCTgTqcclmQOEhiQKCQzJ9BjyLNQuyDkHGYtaio4i8ZSobjc6GQSSEgx+PztkOlb3pqbMRRqRyOGZiEsqIInAB0dIJMSNefXCTlMRATqeUpKQCERwzsYGgZgxIALzuJx+6UnKEy8GaxudX7peX5EOk8/g06y8FmhaaEYG/qPpafPMTe3tUPVxD7jZkDESjUG0PwopWRS6DQ5u4dQkzINAU5+ZGt0N5XNjp1n9KdX9lCQYqE6Yy3OpJJRoBi8wNTodOAmDpNm4G/Rr1JMO0QgDl+g3ORBJNErQOZhSyE4RZaYkwQ4mPzJAm2WY/IhTcA0JTgFBYqDpe4CbXiT1IFDpAcpMpFdyLdoCwpEGkRwdcbVncIJxTUmCB5YUHUQd1QXRmpALPB4NyqeHh/XuGr5PfFN7d32wAIK+A+An6ED8n0nt7yksD51LDdykD5aWHh5pye+n4FuSDy7ffignU9LRHNfJGhnEac5QAU+RcLhmUmpUBy+HuMO1rslBTfIQzGjOnlTdcYRYun4L07Uq6tDvpUJfQ2tbNkDdgUJL3HezmxrkYTjSlj5O9ckX14QyYWPLxZOvMDnJcQlGc2QCo0z8hBcepAhGtAShnE5GfqwMOskSO0mWNnXkYKQk03pV01z2GZHAwWmgZrhKDe1u3LLvgXTIt8pWlUVFqn4P3F7SCdvHeNkNDQyqpFrOh9KG4Ayo2n38OV6OdyllLvDYH0Rl0V1iWWEFEfIfzIhWQd2nHlg6r1+YR++BO7zHUBADQjijGySD6r3HjQr1ggbUc2xS/dU1TR8pFubZlMjbYeO+tFG6VLdng7oS02vDkT9VrsY/VveGvQ7wS4vb5Ev0nDkyn0Q6OIgCKYcCF4ntJ+YZuCGNiMNp1Oz28d5OIFFqRSIThSbIa9INGYx3JxNhRuRqSdkuHPgA4vc9jIf92pJDa6cSHgVNaBjxTKO1TdUybM6VjM0lRHuQcP4ml7KGBkKPi9qWR6mkj7NA4xZjedl7qj7tm/8w01tfNqqDXZTAQ6A7I2BmZ4iNzetgRcnu0brgaMiwARKiDvxbsN1rGB9YiGGdV6ij1S/WNj4CNc3TaeGS+yAcxA5cLrF+7/3M6b5S9vOb0PwHIBDiIjXjMSjP7oHa1vlUiDsBHGEIBNE/5L+hgi1HczqPap5fMOmoN/x736de9wPoY8wEilpuDB4V/fwJQMOloeBPYWMoHXQyGzeG7VLPuUhsb3wAFpdFYf3hVNrXv0b4Prwfx9GflGBSXs6f3LlvlYfpOYYVYhw95MQnRnD0cqAxm+mRFGZeKzkfd1VIrBfP67oOxBhoij8n3iWjCwWINWCSXsLI85al3na+QaW8C+MvzWLp7PVqFgjOsqGyaAOtDV2ObDwEFUWH4IV3NdCyClRgFN3svbgS3YxtvwfPt2ZJIr5lhL2/pGnB9ULKACyd/RZUN5VSQp4UVbuXAvaRqEeS/AcYTz8b234ZIFQAaRjW4zhjCFwnGPshLCt8D6pbiwQRS+UxthR+UjBIA80/puHuW0VDw7Okj/8c5R7DfvdCbeNcCJvdwuV8jjJuilD+3cJPJAuEbsU+3KKiAA0Bbaam5WmWypaggVWjwZ2Lg2oUwcblMGeBpH2hhdqn2kXoaOzUnP2XCQJRtbqoekkJln6/NmNg9gth5vw2MRKcUhXnGBN2oA4XWSQ7nvqQZ75/UPO8JIZDlarxySTN5YaFZtuTKLt2lHxdS7E0IQsH0gluE31oLSodOfNRZhde5wga/ZklP+T0HIZKfAoEJWhczTiJxqBec+gzHTzDvY2YRjUuo5QFWheg3/2+zOugMkzmUcouwXqXqO8mEsRMcOSo41bSFUU1aCWJwjTuuKlJrUARaKn0DajwvgsVuL/VtJwrKMuhmebt2D4D3TULzIgDBi/OIxg5khXevVZbFWVD95rmWXgMlOgQ4kKFcxngEiTqaWss+CwCTX/CTtUoq/HqxhB/HfivtJxHUtO8FaPGN2D5TsHEIgF0K+atlJRg9SYiIGeQsdz46mRJjyFXacFw383kvBi/Gu2LAMvlgNtpXC6JQVjtJPzo+KVB58bshCIrSw25SOp6NjUNP8QYwXw6NWM34Oh3qW5BpiOwSZJrTLgtTaOwLL+LBIIdsq71Qgn8MqHRTWAItXcP4n7yDh63LFBNw9wGK8t6LGNJ0vRIERXn4HTdIqx9LjRSjHioEQ8lKZ1I1QEqzV3AHOijCIwFkhCYRoZFX1wufkcAQUvQXQoH0powRqbylp5WP4Qj0EOJs/BOaqZV4H5chHHlXMgz346/G5dg5AhXGJwMeE2U0OnAXtGKcXBEbVdqAz4+zNH5JA2p+milCQNBIb/UJGm5Wpr8Vrm8OGhVU44LTalXTgXOz3YqB6/CSrVQ1ZwBDjoTKov3oZwDeoYjXkN9jWwXOFO34lHnXizuhFDxHoDXKXiLukwR64UVvg8sceWsqNk/KqlvXcPAK+cm1HYTrgAZZl7xGwAtDhy1WpqH05Bjox644P8llP7AbC99Jz4rrS1GS+2XRM+F6qAXVvpacYkuAYenB3gkiltRSrwlbHMfBe16RPMjVYYDuRmP/P8aei9GxmU9q+U4EPwA5/9qlHwHFpeMOE7jEjzU0GR+x+AxmSonkvF2nI2YdcpK7xC5Sn7l3KMkENrDuLjUpK5nGYmuo3X7zwNuZGIYazOuVfuQnLeoTp9GuR28rageCoI9EFMWBGCmhP/Jwq4n0JpeGQZcyJrQrwjRHya1bR+jJXrQAIII6DolH09osIeF5ipHx+oCaG1Xs6pXGHQVLCZRy4Ml0IPbgAS3zoHy3ng9WFm6h2wM7iCFrZtgU1tIzSy0hBfNCu+bdGNzlWBkHanvCIIZSxWDvY9CGg9BzAW0/sAzTEReMgz9t5Qaz9Latt8h2bjHm2FOyYtW+5L0ghbfIoZ6FNz8C6Xanfjl77ERHTBzEggeMd/Edr9Y3gNNonNAeYGjkujW/CLfyVTQgzfIchBdJRDuPiSQfCUoKoufgxfby6DX6FEkis3oWS4v7YPb8CXGqHlV82I4o9VyPqyGK4t3yaoDy3AxLQYjOgD7W9ut8oQfbhzbDK6C7ejwYKDDE7a84Pj7yuKo2Nz1AKzKieLxqE182uSPv1J3scK3Do0gD4gDj1rykFg+s1OV8xUlf4ZA4xt4MsiFouJGuHKILPHMW3dAblGRcOstsKxgEI1tGXrPZ4JOY7DcF1J1VRL94nHIKz0+DqtQx2+3sANPAc2W0PBPUnaUk5V5wX27+phrvvqSNFHCowDcIoNrX+fT/t7BPNv453SydHSybjSan2q4ruzBifqx302MAK0JPoK7eCuv8NUlSp6EGZzYnJ0/XQig9/NHiHa1je3fJngsIl/V5yEn8zPaj0swnkOc4FSBIkzKk7Y8ZHUAPAVO1WfUsgtOFgLJCfb7+RWvVq7pF4OLwiBKe4DNDBOWPUh0z6Duxu9xFEwMveLRDr1y3MY5xl8x2dSfLFpOXjtJCUbKJFzrrUPC6uFicMG6HY4tPVm5nxBP/n7u8B2VtOiY0M9EX70wAp4CN4X9msllqs5gAP+jZeKxkavTiTqn2zP/5LH1f7SUlOB4OxbRb8MgnH+1+pddD17KBd+p3iN9BIrACfWvuJvyzhygXV1OPnB0WafQzuiWtKxPasU9oE0bkHTGALraEeaEGNGQfBUEwJk/TD7DZux06hCYkOCJurXIb4EIfPf6yLCcip5YLjpySJF8B2xocG5xeWfsiWXkH8LZ3mNqJUcEK+kDrSRMMNwNNNfAzycOcjwCNFGf9rvPj8CXPn1GyH9pu2MrL5j2YdRRlMl4291XzGn8/OrbNWwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBL4eCPwPVA1/wgqb9w0AAAAASUVORK5CYII=
name: Active Directory Query v2
script:
  commands:
  - arguments:
    - description: The username (samAccountName) of the user to modify.
      name: username
      required: true
    - description: Root (for example, DC=domain,DC=com).
      name: base-dn
    description: Expires the password of an Active Directory user.
    name: ad-expire-password
  - arguments:
    - description: The username (samAccountName) of the user to modify.
      name: username
      required: true
    - description: The initial password to set for the user. The user is requested
        to change the password after login.
      name: password
      required: true
    - description: The user DN.
      name: user-dn
      required: true
    - description: The user display name.
      name: display-name
    - description: A short description of the user.
      name: description
    - description: The user email.
      name: email
    - description: The user telephone number.
      name: telephone-number
    - description: The user job title.
      name: title
    - description: Sets basic or custom attributes of the user object. For example,
        custom-attributes="{\"notes\":\"a note about the contact\",\"company\":\"company
        name\"}".
      name: custom-attributes
    description: Creates an Active Directory user. This command requires a secure
      connection (SSL,TLS).
    name: ad-create-user
  - arguments:
    - description: 'Enables you to define search criteria in the Query Active Directory
        using Active Directory syntax. For example, the following query searches for
        all user objects except Andy: "(&(objectCategory=person)(objectClass=user)(!(cn=andy)))".
        Note: If you have special characters such as "*","(",or "\" the character
        must be preceded by two backslashes "\\". For example, to use "*", type "\\*".
        For more information about search filters, see syntax: https://docs.microsoft.com/en-us/windows/win32/adsi/search-filter-syntax'
      name: filter
      required: true
    - description: Root. For example, DC=domain,DC=com). By default, the Base DN configured
        for the instance is used.
      name: base-dn
    - description: A CSV list of the object attributes to return. For example, "dn,memberOf".
        To return all object attributes, specify 'ALL'.
      name: attributes
    - defaultValue: "50"
      description: The maximum number of records to return.
      name: size-limit
    - description: The maximum time to pull records (in seconds).
      name: time-limit
    - auto: PREDEFINED
      defaultValue: "yes"
      description: Whether to output the search results to the context.
      name: context-output
      predefined:
      - "yes"
      - "no"
    - description: The page size to query. The size-limit value will be ignored.
      name: page-size
    - description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      name: page-cookie
    description: Runs Active Directory queries.
    name: ad-search
    outputs:
    - contextPath: ActiveDirectory.Search.dn
      description: The distinguished names that match the query.
      type: string
    - contextPath: ActiveDirectory.Search
      description: The result of the search.
      type: unknown
    - contextPath: ActiveDirectory.SearchPageCookie
      description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      type: string
  - arguments:
    - description: The username of the user to add to the group. If this argument
        is not specified, the computer name argument must be specified.
      name: username
    - description: The name of the computer to add to the group. If this argument
        is not specified, the username argument must be specified.
      name: computer-name
    - description: The name of the group to add the user to.
      name: group-cn
      required: true
    - description: Root. For example, DC=domain,DC=com. By default, the Base DN configured
        for the instance is used.
      name: base-dn
    description: Adds an Active Directory user or computer to a group.
    name: ad-add-to-group
  - arguments:
    - description: The name of the user to remove from the group. If this argument
        is not specified, the computer name argument must be specified.
      name: username
    - description: The name of the computer to remove from the group. If this argument
        is not specified, the username argument must be specified.
      name: computer-name
    - description: The name of the group to remove the user from.
      name: group-cn
      required: true
    - description: Root. For example, DC=domain,DC=com). By default, the Base DN configured
        for the instance is used.
      name: base-dn
    description: Removes an Active Directory user or computer from a group.
    name: ad-remove-from-group
  - arguments:
    - description: The username of the account to update (sAMAccountName).
      name: username
      required: true
    - description: The name of the attribute to modify. For example, sn, displayName,
        mail, and so on.
      name: attribute-name
      required: true
    - description: The value to change the attribute to.
      name: attribute-value
      required: true
    - description: Root. For example, DC=domain,DC=com. By default, the Base DN configured
        for the instance is used.
      name: base-dn
    description: Updates attributes of an existing Active Directory user.
    name: ad-update-user
  - arguments:
    - description: The DN of the user to delete.
      name: user-dn
      required: true
    description: Deletes an Active Directory user.
    name: ad-delete-user
  - arguments:
    - description: The contact DN.
      name: contact-dn
      required: true
    - description: The contact display name.
      name: display-name
    - description: The short description of the contact.
      name: description
    - description: The email address of the contact.
      name: email
    - description: The contact telephone number.
      name: telephone-number
    - description: Sets basic or custom attributes of the contact object. For example,
        custom-attributes="{\"notes\":\"some note about the contact\",\"company\":\"some
        company\"}".
      name: custom-attributes
    - description: The contact job title.
      name: title
    description: Creates an Active Directory contact.
    name: ad-create-contact
  - arguments:
    - description: The contact DN.
      name: contact-dn
      required: true
    - description: The attribute name to update.
      name: attribute-name
      required: true
    - description: The attribute value to update.
      name: attribute-value
      required: true
    description: Updates attributes of an existing Active Directory contact.
    name: ad-update-contact
  - arguments:
    - description: The username of the account to disable (sAMAccountName).
      name: username
      required: true
    - description: Root (e.g., DC=domain,DC=com). By default, the Base DN configured
        for the instance is used.
      name: base-dn
    description: Disables an Active Directory user account.
    name: ad-disable-account
  - arguments:
    - description: The username of the account to enable (sAMAccountName).
      name: username
      required: true
    - description: Root. For example, DC=domain,DC=com). By default, the Base DN configured
        for the instance is used.
      name: base-dn
    - auto: PREDEFINED
      description: If true, the command will enable the user with his restored options.
      name: restore_user
      predefined:
      - "true"
      - "false"
    description: Enables a previously disabled Active Directory account.
    name: ad-enable-account
  - arguments:
    - description: The username of the account to unlock (sAMAccountName).
      name: username
      required: true
    - description: Root. For example, DC=domain,DC=com. By default, the Base DN configured
        for the instance is used.
      name: base-dn
    description: Unlocks a previously locked Active Directory user account.
    name: ad-unlock-account
  - arguments:
    - description: The username of the account to disable (sAMAccountName).
      name: username
      required: true
    - description: The password to set for the user.
      name: password
      required: true
    - description: Root. For example, DC=domain,DC=com. Base DN configured for the
        instance is used as default.
      name: base-dn
    description: Sets a new password for an Active Directory user. This command requires
      a secure connection (SSL,TLS).
    name: ad-set-new-password
  - arguments:
    - description: The name of the computer to modify.
      name: computer-name
      required: true
    - description: Superior DN. For example, OU=computers,DC=domain,DC=com (the specified
        domain must be the same as the current computer domain).
      name: full-superior-dn
    description: Modifies the computer organizational unit within a domain.
    name: ad-modify-computer-ou
  - arguments:
    - description: The name of the user to modify.
      name: user-name
      required: true
    - description: Superior DN. For example, OU=users,DC=domain,DC=com (the specified
        domain must be the same as the current user domain).
      name: full-superior-dn
    description: Modifies the user organizational unit within a domain.
    name: ad-modify-user-ou
  - arguments:
    - default: true
      description: The Distinguished Name of the user in which to return information.
      name: dn
    - description: The name of the user to return information.
      name: name
    - description: Adds AD attributes of the resulting objects to the default attributes.
      name: attributes
    - description: Removes AD attributes of the resulting objects from the attributes.
      name: attributes-to-exclude
    - description: Queries users by custom field type.
      name: custom-field-type
    - description: Queries users by custom field data (relevant only if the `custom-field-type`
        argument is provided).
      name: custom-field-data
    - description: Queries users by the samAccountName attribute.
      name: username
    - description: Queries users by the samAccountName attribute.
      name: sAMAccountName
    - description: Queries by the user's email address.
      name: email
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to include verbose translation for UserAccountControl flags.
        Default is false.
      name: user-account-control-out
      predefined:
      - "true"
      - "false"
    - defaultValue: "20"
      description: The maximum number of objects to return.
      name: limit
    - description: The page size to query. The limit value will be ignored.
      name: page-size
    - description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      name: page-cookie
    description: Retrieves detailed information about a user account. The user can
      be specified by name, email address, or as an Active Directory Distinguished
      Name (DN). If no filter is specified, all users are returned.
    name: ad-get-user
    outputs:
    - contextPath: ActiveDirectory.Users.dn
      description: The user distinguished name.
      type: string
    - contextPath: ActiveDirectory.Users.displayName
      description: The user display name.
      type: string
    - contextPath: ActiveDirectory.Users.name
      description: The user common name.
      type: string
    - contextPath: ActiveDirectory.Users.sAMAccountName
      description: The user sAMAccountName.
      type: string
    - contextPath: ActiveDirectory.Users.userAccountControl
      description: The user account control flag.
      type: number
    - contextPath: ActiveDirectory.Users.mail
      description: The user email address.
      type: string
    - contextPath: ActiveDirectory.Users.manager
      description: The manager of the user.
      type: string
    - contextPath: ActiveDirectory.Users.memberOf
      description: Groups in which the user is a member.
      type: string
    - contextPath: ActiveDirectory.Users.userAccountControlFields.SCRIPT
      description: Whether the login script is run. Works for *Windows Server 2012
        R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.ACCOUNTDISABLE
      description: Whether the user account is disabled. Works for *Windows Server
        2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.HOMEDIR_REQUIRED
      description: Whether the home folder is required. Works for *Windows Server
        2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.LOCKOUT
      description: Whether the user is locked out. Works for *Windows Server 2012
        R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.PASSWD_NOTREQD
      description: Whether the password is required. Works for *Windows Server 2012
        R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.PASSWD_CANT_CHANGE
      description: Whether the user can change the password. Works for *Windows Server
        2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.ENCRYPTED_TEXT_PWD_ALLOWED
      description: Whether the user can send an encrypted password. Works for *Windows
        Server 2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.TEMP_DUPLICATE_ACCOUNT
      description: Whether this is an account for users whose primary account is in
        another domain. Works for *Windows Server 2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.NORMAL_ACCOUNT
      description: Whether this is a default account type that represents a typical
        user. Works for *Windows Server 2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.INTERDOMAIN_TRUST_ACCOUNT
      description: Whether the account is permitted to trust a system domain that
        trusts other domains. Works for *Windows Server 2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.WORKSTATION_TRUST_ACCOUNT
      description: Whether this is a computer account for a computer running Microsoft
        Windows NT 4.0 Workstation, Microsoft Windows NT 4.0 Server, Microsoft Windows
        2000 Professional, or Windows 2000 Server and is a member of this domain.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.SERVER_TRUST_ACCOUNT
      description: Whether this is a computer account for a domain controller that
        is a member of this domain. Works for *Windows Server 2012 R2*.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.DONT_EXPIRE_PASSWORD
      description: Whether to never expire the password on the account.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.MNS_LOGON_ACCOUNT
      description: Whether this is an MNS login account.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.SMARTCARD_REQUIRED
      description: Whether to force the user to log in by using a smart card.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.TRUSTED_FOR_DELEGATION
      description: Whether the service account (the user or computer account) under
        which a service runs is trusted for Kerberos delegation.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.NOT_DELEGATED
      description: Whether the security context of the user isn't delegated to a service
        even if the service account is set as trusted for Kerberos delegation.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.USE_DES_KEY_ONLY
      description: Whether to restrict this principal to use only Data Encryption
        Standard (DES) encryption types for keys.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.DONT_REQ_PREAUTH
      description: Whether this account require Kerberos pre-authentication for logging
        on.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.PASSWORD_EXPIRED
      description: Whether the user password expired.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.TRUSTED_TO_AUTH_FOR_DELEGATION
      description: Whether the account is enabled for delegation.
      type: bool
    - contextPath: ActiveDirectory.Users.userAccountControlFields.PARTIAL_SECRETS_ACCOUNT
      description: Whether the account is a read-only domain controller (RODC).
      type: bool
    - contextPath: ActiveDirectory.UsersPageCookie
      description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      type: string
    - contextPath: Account.DisplayName
      description: The user display name.
      type: string
    - contextPath: Account.Groups
      description: Groups for which the user is a member.
      type: string
    - contextPath: Account.Manager
      description: The user manager.
      type: string
    - contextPath: Account.ID
      description: The user distinguished name.
      type: string
    - contextPath: Account.Username
      description: The user samAccountName.
      type: string
    - contextPath: Account.Email
      description: The user email address.
      type: string
  - arguments:
    - description: The computer's DN.
      name: dn
    - description: The name of the computer to return information about.
      name: name
    - description: Adds AD attributes of the resulting objects to the default attributes.
      name: attributes
    - description: Search computers by custom field data (relevant only if the `customFieldType`
        argument is provided).
      name: custom-field-data
    - description: Search the computer by custom field type.
      name: custom-field-type
    - description: The maximum number of records to return.
      name: limit
    - description: The page size to query. The limit value will be ignored.
      name: page-size
    - description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      name: page-cookie
    description: Retrieves detailed information about a computer account. The computer
      can be specified by name, email address, or as an Active Directory Distinguished
      Name (DN). If no filters are provided, all computers are returned.
    name: ad-get-computer
    outputs:
    - contextPath: ActiveDirectory.Computers.dn
      description: The computer distinguished name.
    - contextPath: ActiveDirectory.Computers.memberOf
      description: Groups for which the computer is listed.
    - contextPath: ActiveDirectory.Computers.name
      description: The computer name.
    - contextPath: Endpoint.ID
      description: The computer DN.
    - contextPath: Endpoint.Hostname
      description: The computer host name.
    - contextPath: Endpoint.Groups
      description: Groups for which the computer is listed as a member.
    - contextPath: ActiveDirectory.ComputersPageCookie
      description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      type: string
  - arguments:
    - description: The Distinguished Name of the Group's Active Directory.
      name: group-dn
      required: true
    - auto: PREDEFINED
      defaultValue: person
      description: 'The type of members to search. Can be: "Person", or "computer".
        Default is person.'
      name: member-type
      predefined:
      - person
      - computer
      - group
      required: true
    - description: CSV list of attributes to include in the results, in addition to
        the default attributes.
      name: attributes
    - defaultValue: "180"
      description: Time limit (in seconds) for the search to run.
      name: time_limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to disable recursive retrieval of group memberships of
        a user.
      name: disable-nested-search
      predefined:
      - "false"
      - "true"
    - defaultValue: '*'
      description: Queries results by the samAccountName attribute.
      name: sAMAccountName
    - description: The maximum number of records to return.
      name: limit
    - description: The page size to query. The limit value will be ignored.
      name: page-size
    - description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      name: page-cookie
    description: Retrieves the list of users or computers that are members of the
      specified group.
    name: ad-get-group-members
    outputs:
    - contextPath: ActiveDirectory.Groups.dn
      description: The group DN.
      type: string
    - contextPath: ActiveDirectory.Groups.members.dn
      description: The group member DN.
      type: string
    - contextPath: ActiveDirectory.Groups.members.category
      description: The group members category.
      type: string
    - contextPath: ActiveDirectory.GroupsPageCookie
      description: An opaque string received in a paged search, used for requesting
        subsequent entries.
      type: string
  - arguments:
    - description: The Active Directory name of the group.
      name: name
      required: true
    - auto: PREDEFINED
      description: 'The type of group. Can be: "security", or "distribution".'
      name: group-type
      predefined:
      - security
      - distribution
      required: true
    - description: The Full Distinguished Name (DN) of the group. Use double quotes
        ("") rather than single quotes ('') when initializing this command.
      name: dn
      required: true
    - description: The Full DN Of users or groups that will be members of the newly
        created group.
      isArray: true
      name: members
    description: Creates a new security or distribution Active Directory group.
    execution: true
    name: ad-create-group
  - arguments:
    - description: The Active Directory Distinguished Name (DN) of the group.
      name: dn
      required: true
    description: Deletes an existing Active Directory security or distribution group.
    execution: true
    name: ad-delete-group
  - arguments:
    - description: A User Profile indicator that contains user information, such as
        name, email address, etc.
      name: user-profile
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: When set to true, after the command execution the status of the
        user in the 3rd-party integration will be active.
      name: allow-enable
      predefined:
      - "true"
      - "false"
    description: Creates an Active Directory user. This command requires a secure
      connection (SSL,TLS).
    name: iam-create-user
    outputs:
    - contextPath: IAM.UserProfile
      description: The user profile.
      type: Unknown
    - contextPath: IAM.Vendor.active
      description: If true, the employee status is active.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: The integration name.
      type: String
    - contextPath: IAM.Vendor.details
      description: Tells the user if the API was successful, otherwise provides error
        information.
      type: Unknown
    - contextPath: IAM.Vendor.email
      description: The employee email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: The HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: The reason the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: The name of the integration instance.
      type: Unknown
    - contextPath: IAM.Vendor.success
      description: If true, the command executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee username in the app.
      type: String
    - contextPath: IAM.Vendor.action
      description: The command name.
      type: String
  - arguments:
    - description: A User Profile indicator that contains user information, such as
        name and email address.
      name: user-profile
      required: true
    description: Retrieves a single user resource.
    name: iam-get-user
    outputs:
    - contextPath: IAM.UserProfile
      description: The user profile.
      type: Unknown
    - contextPath: IAM.Vendor.active
      description: If true the employee status is active.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: The integration name.
      type: String
    - contextPath: IAM.Vendor.details
      description: Tells the user if the API was successful, otherwise provides error
        information.
      type: Unknown
    - contextPath: IAM.Vendor.email
      description: The employee email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: The HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: The reason the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: The integration instance name.
      type: Unknown
    - contextPath: IAM.Vendor.success
      description: If true, the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee username in the app.
      type: String
    - contextPath: IAM.Vendor.action
      description: The command name.
      type: String
  - arguments:
    - description: A User Profile indicator that contains user information, such as
        name and email address.
      name: user-profile
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: When set to true, after the command executes the user status in
        the 3rd-party integration is active.
      name: allow-enable
      predefined:
      - "true"
      - "false"
    description: Updates an existing user with the data in the User Profile indicator
      that is passed in the user-profile argument.
    name: iam-update-user
    outputs:
    - contextPath: IAM.UserProfile
      description: The user profile.
      type: Unknown
    - contextPath: IAM.Vendor.active
      description: Gives the active status of user. Can be true or false.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: The integration name.
      type: String
    - contextPath: IAM.Vendor.details
      description: Tells the user if the API was successful, otherwise provides error
        information.
      type: Unknown
    - contextPath: IAM.Vendor.email
      description: The employee email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: The HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: The reason the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: The integration instance name.
      type: Unknown
    - contextPath: IAM.Vendor.success
      description: If true, the command executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee username in the app.
      type: String
    - contextPath: IAM.Vendor.action
      description: The command name.
      type: String
  - arguments:
    - description: A User Profile indicator that contains user information, such as
        name and email address.
      name: user-profile
      required: true
    description: Disables a user.
    execution: true
    name: iam-disable-user
    outputs:
    - contextPath: IAM.UserProfile
      description: The user profile.
      type: Unknown
    - contextPath: IAM.Vendor.active
      description: Gives the active status of user. Can be true or false.
      type: Boolean
    - contextPath: IAM.Vendor.brand
      description: The integration name.
      type: String
    - contextPath: IAM.Vendor.details
      description: Tells the user if the API was successful, otherwise provides error
        information.
      type: Unknown
    - contextPath: IAM.Vendor.email
      description: The employee email address.
      type: String
    - contextPath: IAM.Vendor.errorCode
      description: The HTTP error response code.
      type: Number
    - contextPath: IAM.Vendor.errorMessage
      description: The reason the API failed.
      type: String
    - contextPath: IAM.Vendor.id
      description: The employee user ID in the app.
      type: String
    - contextPath: IAM.Vendor.instanceName
      description: The integration instance name.
      type: Unknown
    - contextPath: IAM.Vendor.success
      description: If true, the command was executed successfully.
      type: Boolean
    - contextPath: IAM.Vendor.username
      description: The employee username in the app.
      type: String
    - contextPath: IAM.Vendor.action
      description: The command name.
      type: String
  - arguments: []
    description: Retrieves a User Profile schema which holds all of the user fields
      in the application. Used for outgoing mapping through the Get Schema option.
    name: get-mapping-fields
  - arguments:
    - description: The group name of the group to update (sAMAccountName).
      name: groupname
    - description: The name of the attribute to modify. For example, Description and
        displayName.
      name: attributename
      required: true
    - description: The value of the attribute to change.
      name: attributevalue
      required: true
    - description: Root. For example, DC=domain,DC=com. By default, the Base DN configured
        for the instance is used.
      name: basedn
    description: Updates attributes of an existing Active Directory group.
    name: ad-update-group
  - arguments:
    - description: The sAMAccountName of the user to modify.
      name: username
      required: true
    - auto: PREDEFINED
      description: Value to set "Password Never Expire".
      name: value
      predefined:
      - "true"
      - "false"
      required: true
    description: Modifies the AD account attribute "Password Never Expire".
    execution: true
    name: ad-modify-password-never-expire
  - arguments:
    - description: Username to test. By itself or formatted like SERVER_IP\\USERNAME.
      name: username
      required: true
    - description: Password to test.
      name: password
      required: true
    description: Test given credentials.
    name: ad-test-credentials
    outputs:
    - contextPath: ActiveDirectory.ValidCredentials
      description: List of usernames that successfully logged in.
  dockerimage: demisto/ldap:2.9.1.75534
  ismappable: true
  isremotesyncout: true
  runonce: false
  script: |
    register_module_line('Active Directory Query v2', 'start', __line__())
    ### pack version: 1.6.25




    from ldap3.core.exceptions import LDAPBindError, LDAPSocketOpenError, LDAPStartTLSError, LDAPSocketReceiveError

    from ldap3 import Server, Connection, NTLM, SUBTREE, ALL_ATTRIBUTES, Tls, Entry, Reader, ObjectDef, \
        AUTO_BIND_TLS_BEFORE_BIND, AUTO_BIND_NO_TLS
    from ldap3.extend import microsoft
    import ssl
    from datetime import datetime
    import os
    from ldap3.utils.log import (set_library_log_detail_level, get_library_log_detail_level,
                                 set_library_log_hide_sensitive_data, EXTENDED)
    from ldap3.utils.conv import escape_filter_chars

    ''' GLOBAL VARS '''

    CIPHERS_STRING = '@SECLEVEL=1:ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:ECDH+AESGCM:' \
                     'DH+AESGCM:ECDH+AES:DH+AES:RSA+ANESGCM:RSA+AES:!aNULL:!eNULL:!MD5:!DSS'  # Allowed ciphers for SSL/TLS
    DEFAULT_TIMEOUT = 120  # timeout for ssl/tls socket
    START_TLS = 'Start TLS'
    TLS = 'TLS'
    SSL = 'SSL'
    SSL_VERSIONS = {
        'None': None,
        'TLS': ssl.PROTOCOL_TLS,
        'TLSv1': ssl.PROTOCOL_TLSv1,  # guardrails-disable-line
        'TLSv1_1': ssl.PROTOCOL_TLSv1_1,  # guardrails-disable-line
        'TLSv1_2': ssl.PROTOCOL_TLSv1_2,
        'TLS_CLIENT': ssl.PROTOCOL_TLS_CLIENT
    }
    # global connection
    connection: Connection | None = None

    # userAccountControl is a bitmask used to store a number of settings.
    # find more at:
    # https://support.microsoft.com/en-gb/help/305144/how-to-use-the-useraccountcontrol-flags-to-manipulate-user-account-pro
    DEFAULT_OUTGOING_MAPPER = "User Profile - Active Directory (Outgoing)"
    DEFAULT_INCOMING_MAPPER = "User Profile - Active Directory (Incoming)"

    COMMON_ACCOUNT_CONTROL_FLAGS = {
        512: "Enabled Account",
        514: "Disabled account",
        544: "Password Not Required",
        4096: "Workstation/server",
        66048: "Enabled, password never expires",
        66050: "Disabled, password never expires",
        66080: "Enables, password never expires, password not required.",
        532480: "Domain controller"
    }
    NORMAL_ACCOUNT = 512
    DISABLED_ACCOUNT = 514
    PASSWORD_NOT_REQUIRED = 544
    INACTIVE_LIST_OPTIONS = [514, 546, 66050, 66082, 262658, 262690, 328226]
    DEFAULT_LIMIT = 20

    # common attributes for specific AD objects
    DEFAULT_PERSON_ATTRIBUTES = [
        'name',
        'displayName',
        'memberOf',
        'mail',
        'sAMAccountName',
        'manager',
        'userAccountControl'
    ]
    DEFAULT_COMPUTER_ATTRIBUTES = [
        'name',
        'memberOf'
    ]
    DEFAULT_GROUP_ATTRIBUTES = [
        'name',
        'memberOf'
    ]
    FIELDS_THAT_CANT_BE_MODIFIED = [
        "dn", "cn", "ou"
    ]

    ''' HELPER FUNCTIONS '''


    def get_ssl_version(ssl_version):
        """
            Returns the ssl version object according to the user's selection.
        """
        version = SSL_VERSIONS.get(ssl_version)
        if version:
            demisto.info(f"SSL/TLS protocol version is {ssl_version} ({version}).")
        else:  # version is None
            demisto.info("SSL/TLS protocol version is None (the default value of the ldap3 Tls object).")

        return version


    def get_tls_object(unsecure, ssl_version):
        """
            Returns a TLS object according to the user's selection of the 'Trust any certificate' checkbox.
        """
        if unsecure:  # Trust any certificate is checked
            # Trust any certificate = True means that we do not require validation of the LDAP server's certificate,
            # and allow the use of all possible ciphers.
            tls = Tls(validate=ssl.CERT_NONE, ca_certs_file=None, ciphers=CIPHERS_STRING,
                      version=get_ssl_version(ssl_version))

        else:  # Trust any certificate is unchecked
            # Trust any certificate = False means that the LDAP server's certificate must be valid -
            # i.e if the server's certificate is not valid the connection will fail.
            tls = Tls(validate=ssl.CERT_REQUIRED, ca_certs_file=os.environ.get('SSL_CERT_FILE'),
                      version=get_ssl_version(ssl_version))

        return tls


    def initialize_server(host, port, secure_connection, unsecure, ssl_version):
        """
        Uses the instance configuration to initialize the LDAP server.
        Supports both encrypted and non encrypted connection.

        :param host: host or ip
        :type host: string
        :param port: port or None
        :type port: number
        :param secure_connection: SSL, TLS, Start TLS or None
        :type secure_connection: string
        :param unsecure: trust any certificate
        :type unsecure: boolean
        :param ssl_version: ssl version
        :type unsecure: string
        :return: ldap3 Server
        :rtype: Server
        """
        if secure_connection == TLS:
            # Kept the TLS option for backwards compatibility only.
            # For establishing a secure connection via SSL/TLS protocol - use the 'SSL' option.
            # For establishing a secure connection via Start TLS - use the 'Start TLS' option.
            demisto.debug(f"initializing sever with TLS (unsecure: {unsecure}). port: {port or 'default(636)'}")
            if unsecure:
                # Add support for all CIPHERS_STRING
                tls = Tls(validate=ssl.CERT_NONE, ciphers=CIPHERS_STRING, version=get_ssl_version(ssl_version))
            else:
                tls = Tls(validate=ssl.CERT_NONE, version=get_ssl_version(ssl_version))
            if port:
                return Server(host, port=port, use_ssl=unsecure, tls=tls)
            return Server(host, use_ssl=unsecure, tls=tls)

        if secure_connection == SSL:  # Secure connection (SSL\TLS)
            demisto.info(f"Initializing LDAP sever with SSL/TLS (unsecure: {unsecure})."
                         f" port: {port or 'default(636)'}")
            tls = get_tls_object(unsecure, ssl_version)
            return Server(host=host, port=port, use_ssl=True, tls=tls, connect_timeout=DEFAULT_TIMEOUT)

        elif secure_connection == START_TLS:  # Secure connection (STARTTLS)
            demisto.info(f"Initializing LDAP sever without a secure connection - Start TLS operation will be executed"
                         f" during bind. (unsecure: {unsecure}). port: {port or 'default(389)'}")
            tls = get_tls_object(unsecure, ssl_version)
            return Server(host=host, port=port, use_ssl=False, tls=tls, connect_timeout=DEFAULT_TIMEOUT)

        else:  # Unsecure (non encrypted connection initialized) - connection type is None
            demisto.info(f"Initializing LDAP sever without a secure connection. port: {port or 'default(389)'}")
            return Server(host=host, port=port, connect_timeout=DEFAULT_TIMEOUT)


    def user_account_to_boolean_fields(user_account_control):
        """
        parse the userAccountControl into boolean values.
        following the values from:
        https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties
        """
        return {
            'SCRIPT': bool(user_account_control & 0x0001),
            'ACCOUNTDISABLE': bool(user_account_control & 0x0002),
            'HOMEDIR_REQUIRED': bool(user_account_control & 0x0008),
            'LOCKOUT': bool(user_account_control & 0x0010),
            'PASSWD_NOTREQD': bool(user_account_control & 0x0020),
            'PASSWD_CANT_CHANGE': bool(user_account_control & 0x0040),
            'ENCRYPTED_TEXT_PWD_ALLOWED': bool(user_account_control & 0x0080),
            'TEMP_DUPLICATE_ACCOUNT': bool(user_account_control & 0x0100),
            'NORMAL_ACCOUNT': bool(user_account_control & 0x0200),
            'INTERDOMAIN_TRUST_ACCOUNT': bool(user_account_control & 0x0800),
            'WORKSTATION_TRUST_ACCOUNT': bool(user_account_control & 0x1000),
            'SERVER_TRUST_ACCOUNT': bool(user_account_control & 0x2000),
            'DONT_EXPIRE_PASSWORD': bool(user_account_control & 0x10000),
            'MNS_LOGON_ACCOUNT': bool(user_account_control & 0x20000),
            'SMARTCARD_REQUIRED': bool(user_account_control & 0x40000),
            'TRUSTED_FOR_DELEGATION': bool(user_account_control & 0x80000),
            'NOT_DELEGATED': bool(user_account_control & 0x100000),
            'USE_DES_KEY_ONLY': bool(user_account_control & 0x200000),
            'DONT_REQ_PREAUTH': bool(user_account_control & 0x400000),
            'PASSWORD_EXPIRED': bool(user_account_control & 0x800000),
            'TRUSTED_TO_AUTH_FOR_DELEGATION': bool(user_account_control & 0x1000000),
            'PARTIAL_SECRETS_ACCOUNT': bool(user_account_control & 0x04000000),
        }


    def account_entry(person_object, custom_attributes):
        # create an account entry from a person objects
        account = {
            'Type': 'AD',
            'ID': person_object.get('dn'),
            'Email': person_object.get('mail'),
            'Username': person_object.get('sAMAccountName'),
            'DisplayName': person_object.get('displayName'),
            'Managr': person_object.get('manager'),
            'Manager': person_object.get('manager'),
            'Groups': person_object.get('memberOf')
        }

        lower_cased_person_object_keys = {
            person_object_key.lower(): person_object_key for person_object_key in person_object
        }

        for attr in custom_attributes:
            try:
                account[attr] = person_object[attr]
            except KeyError as e:
                lower_cased_custom_attr = attr.lower()
                if lower_cased_custom_attr in lower_cased_person_object_keys:
                    cased_custom_attr = lower_cased_person_object_keys.get(lower_cased_custom_attr, '')
                    account[cased_custom_attr] = person_object[cased_custom_attr]
                else:
                    demisto.error(f'Failed parsing custom attribute {attr}, error: {e}')

        return account


    def endpoint_entry(computer_object, custom_attributes):
        # create an endpoint entry from a computer object
        endpoint = {
            'Type': 'AD',
            'ID': computer_object.get('dn'),
            'Hostname': computer_object.get('name'),
            'Groups': computer_object.get('memberOf')
        }

        lower_cased_person_object_keys = {
            person_object_key.lower(): person_object_key for person_object_key in computer_object
        }

        for attr in custom_attributes:
            if attr == '*':
                continue
            try:
                endpoint[attr] = computer_object[attr]
            except KeyError as e:
                lower_cased_custom_attr = attr.lower()
                if lower_cased_custom_attr in lower_cased_person_object_keys:
                    cased_custom_attr = lower_cased_person_object_keys.get(lower_cased_custom_attr, '')
                    endpoint[cased_custom_attr] = computer_object[cased_custom_attr]
                else:
                    demisto.error(f'Failed parsing custom attribute {attr}, error: {e}')

        return endpoint


    def group_entry(group_object, custom_attributes):
        # create an group entry from a group object
        group = {
            'Type': 'AD',
            'ID': group_object.get('dn'),
            'Name': group_object.get('name'),
            'Groups': group_object.get('memberOf'),
        }

        lower_cased_person_object_keys = {
            person_object_key.lower(): person_object_key for person_object_key in group_object
        }

        for attr in custom_attributes:
            if attr == '*':
                continue
            try:
                group[attr] = group_object[attr]
            except KeyError as e:
                lower_cased_custom_attr = attr.lower()
                if lower_cased_custom_attr in lower_cased_person_object_keys:
                    cased_custom_attr = lower_cased_person_object_keys.get(lower_cased_custom_attr, '')
                    group[cased_custom_attr] = group_object[cased_custom_attr]
                else:
                    demisto.error(f'Failed parsing custom attribute {attr}, error: {e}')

        return group


    def base_dn_verified(base_dn):
        # search AD with a simple query to test base DN is configured correctly
        try:
            search(
                "(objectClass=user)",
                base_dn,
                size_limit=1
            )
        except Exception as e:
            demisto.info(str(e))
            return False
        return True


    def generate_unique_cn(default_base_dn, cn):
        changing_cn = cn
        i = 1
        while check_if_user_exists_by_attribute(default_base_dn, "cn", changing_cn):
            changing_cn = cn + str(i)
            i += 1
            if i == 30:
                raise Exception("User CN couldn't be generated")
        return changing_cn


    def generate_dn_and_remove_from_user_profile(default_base_dn, user):
        """Generates a user dn, in case user dn is included in the user, will return it, otherwise
        will generate one using the cn and ou values
        :param default_base_dn: The location in the DIT where the search will start
        :param user: The user dict including his values
        :return: The user's dn.
        """
        user_dn = user.get("dn")

        if user_dn:
            user.pop("dn")
            return user_dn
        user_cn = user.get("cn")
        if not user_cn:
            raise Exception("User must have cn, please provide a valid value")

        valid_cn = generate_unique_cn(default_base_dn, user.get("cn"))
        ou = user.get("ou")

        return 'CN=' + str(valid_cn) + ',' + str(ou)


    def check_if_user_exists_by_attribute(default_base_dn, attr, val):
        """Check if user exists base on a specific attribute
        :param default_base_dn: The location in the DIT where the search will start
        :param attr: The attribute to search by
        :param val: The attribute's value
        :return: True if the user exists, False otherwise.
        """
        query = f'(&(objectClass=User)(objectCategory=person)({attr}={val}))'
        entries = search_with_paging(
            query,
            default_base_dn,
            attributes=[attr],
            size_limit=1,
            page_size=1
        )
        if entries.get('flat'):
            return True
        return False


    def get_user_activity_by_samaccountname(default_base_dn, samaccountname):
        """Get if user is active or not by samaccountname
        :param default_base_dn: The location in the DIT where the search will start
        :param samaccountname: The user's unique samaccountname
        :return: True if the user active, False otherwise.
        """
        active = False
        query = f'(&(objectClass=User)(objectCategory=person)(sAMAccountName={samaccountname}))'
        entries = search_with_paging(
            query,
            default_base_dn,
            attributes=["userAccountControl"],
            size_limit=1,
            page_size=1
        )

        if entries.get('flat'):
            user = entries.get('flat')[0]
            activity = user.get('userAccountControl')[0]
            active = activity not in INACTIVE_LIST_OPTIONS

        return active


    def get_user_dn_by_email(default_base_dn, email):
        """Get's user dn by it's email, this function assumes that user's unique sameaccountname it the email prefix
        :param default_base_dn: The location in the DIT where the search will start
        :param email: The user's email
        :return: the user's dn
        """
        dn = ''
        samaccountname = email.split('@')[0]
        query = f'(&(objectClass=User)(objectCategory=person)(sAMAccountName={samaccountname}))'
        entries = search_with_paging(
            query,
            default_base_dn,
            attributes=["sAMAccountName"],
            size_limit=1,
            page_size=1
        )

        if entries.get('flat'):
            user = entries.get('flat')[0]
            dn = user.get('dn')

        return dn


    def modify_user_ou(dn, new_ou):
        assert connection is not None
        cn = dn.split(',', 1)[0]

        success = connection.modify_dn(dn, cn, new_superior=new_ou)
        return success


    def get_all_attributes(search_base):
        obj_inetorgperson = ObjectDef('user', connection)
        r = Reader(connection, obj_inetorgperson, search_base)
        r.search()
        if not r:
            return []
        if not r[0]:
            return []
        attributes = r[0].allowedAttributes
        return list(attributes)


    ''' COMMANDS '''

    ''' SEARCH '''


    def search(search_filter, search_base, attributes=None, size_limit=0, time_limit=0):
        """
        find entries in the DIT

        Args:
            search_base: the location in the DIT where the search will start
            search_filter: LDAP query string
            attributes: the attributes to specify for each entry found in the DIT

        """
        assert connection is not None
        success = connection.search(
            search_base=search_base,
            search_filter=search_filter,
            attributes=attributes,
            size_limit=size_limit,
            time_limit=time_limit
        )

        if not success:
            raise Exception("Search failed")
        return connection.entries


    def search_with_paging(search_filter, search_base, attributes=None, page_size=100, size_limit=0,
                           time_limit=0, page_cookie=None):
        """
        find entries in the DIT

        Args:
            search_base: the location in the DIT where the search will start
            search_filter: LDAP query string
            attributes: the attributes to specify for each entry found in the DIT
        """
        assert connection is not None
        total_entries = 0
        cookie = base64.b64decode(page_cookie) if page_cookie else None
        start = datetime.now()

        entries: list[Entry] = []
        entries_left_to_fetch = size_limit
        while True:
            if 0 < entries_left_to_fetch < page_size:
                page_size = entries_left_to_fetch
            connection.search(
                search_base,
                search_filter,
                search_scope=SUBTREE,
                attributes=attributes,
                paged_size=page_size,
                paged_cookie=cookie
            )
            entries_left_to_fetch -= len(connection.entries)
            total_entries += len(connection.entries)
            cookie = dict_safe_get(connection.result, ['controls', '1.2.840.113556.1.4.319', 'value', 'cookie'])
            time_diff = (datetime.now() - start).seconds

            entries.extend(connection.entries)

            # stop when: 1.reached size limit 2.reached time limit 3. no cookie
            if (size_limit and size_limit <= total_entries) or (time_limit and time_diff >= time_limit) or (not cookie):
                break

        # keep the raw entry for raw content (backward compatibility)
        raw = []
        # flatten the entries
        flat = []

        for entry in entries:
            entry = json.loads(entry.entry_to_json())

            flat_entry = {
                'dn': entry['dn']
            }

            for attr in entry.get('attributes', {}):
                flat_entry[attr] = entry['attributes'][attr]

            raw.append(entry)
            flat.append(flat_entry)
        encode_cookie = b64_encode(cookie) if cookie else None
        return {
            "raw": raw,
            "flat": flat,
            "page_cookie": encode_cookie
        }


    def user_dn(sam_account_name, search_base):
        search_filter = f'(&(objectClass=user)(sAMAccountName={sam_account_name}))'
        entries = search(
            search_filter,
            search_base
        )
        if not entries:
            raise Exception(f"Could not get full DN for user with sAMAccountName '{sam_account_name}'")
        entry = json.loads(entries[0].entry_to_json())
        return entry['dn']


    def computer_dn(compuer_name, search_base):
        search_filter = f'(&(objectClass=user)(objectCategory=computer)(name={compuer_name}))'
        entries = search(
            search_filter,
            search_base
        )
        if not entries:
            raise Exception(f"Could not get full DN for computer with name '{compuer_name}'")
        entry = json.loads(entries[0].entry_to_json())
        return entry['dn']


    def group_dn(group_name, search_base):
        group_name = escape_filter_chars(group_name)
        search_filter = f'(&(objectClass=group)(cn={group_name}))'
        entries = search(
            search_filter,
            search_base
        )
        if not entries:
            raise Exception(f"Could not get full DN for group with name '{group_name}'")
        entry = json.loads(entries[0].entry_to_json())
        return entry['dn']


    def convert_special_chars_to_unicode(search_filter):
        # We allow users to use special chars without explicitly typing their unicode values
        chars_to_replace = {
            '\\(': '\\28',
            '\\)': '\\29',
            '\\*': '\\2a',
            '\\/': '\\2f',
            '\\\\': '\\5c'
        }
        for i, j in chars_to_replace.items():
            search_filter = search_filter.replace(i, j)

        return search_filter


    def free_search(default_base_dn, page_size):
        args = demisto.args()

        search_filter = args.get('filter')
        size_limit = int(args.get('size-limit', '0'))
        time_limit = int(args.get('time-limit', '0'))
        search_base = args.get('base-dn') or default_base_dn
        attributes = args.get('attributes')
        context_output = args.get('context-output')

        search_filter = convert_special_chars_to_unicode(search_filter)

        # if ALL was specified - get all the object's attributes, else expect a string of comma separated values
        if attributes:
            attributes = ALL_ATTRIBUTES if attributes == 'ALL' else attributes.split(',')

        page_cookie = args.get('page-cookie')
        if args.get('page-size'):
            page_size = arg_to_number(args['page-size'])
            size_limit = page_size

        entries = search_with_paging(
            search_filter,
            search_base,
            attributes=attributes,
            size_limit=size_limit,
            time_limit=time_limit,
            page_size=page_size,
            page_cookie=page_cookie
        )
        ec = {} if context_output == 'no' else {'ActiveDirectory.Search(obj.dn == val.dn)': entries['flat'],
                                                'ActiveDirectory(true)': {
                                                    'SearchPageCookie': entries['page_cookie']}
                                                }
        demisto_entry = {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': entries['raw'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Active Directory Search", entries['flat']),
            'EntryContext': ec
        }
        demisto.results(demisto_entry)


    def search_users(default_base_dn, page_size):
        # this command is equivalent to script ADGetUser
        # will preform a custom search to find users by a specific (one) attribute specified by the user

        args = demisto.args()

        attributes: list[str] = []
        custom_attributes: list[str] = []

        # zero is actually no limitation, default is 20
        limit = int(args.get('limit', '20'))
        if limit <= 0:
            limit = 20

        page_cookie = args.get('page-cookie')
        if args.get('page-size'):
            page_size = arg_to_number(args['page-size'])
            limit = page_size

        # default query - list all users
        query = "(&(objectClass=User)(objectCategory=person))"
        # query by user DN
        if args.get('dn'):
            dn = escape_filter_chars(args['dn'])
            query = f"(&(objectClass=User)(objectCategory=person)(distinguishedName={dn}))"

        # query by name
        if args.get('name'):
            name = escape_filter_chars(args['name'])
            query = f"(&(objectClass=User)(objectCategory=person)(cn={name}))"

        # query by email
        if args.get('email'):
            email = escape_filter_chars(args['email'])
            query = f"(&(objectClass=User)(objectCategory=person)(mail={email}))"

        # query by sAMAccountName
        if args.get('username') or args.get('sAMAccountName'):
            username = escape_filter_chars(args['username']) if args.get('username') else escape_filter_chars(args['sAMAccountName'])
            query = f"(&(objectClass=User)(objectCategory=person)(sAMAccountName={username}))"

        # query by custom object attribute
        if args.get('custom-field-type'):
            if not args.get('custom-field-data'):
                raise Exception('Please specify "custom-field-data" as well when quering by "custom-field-type"')
            field_type = escape_filter_chars(args['custom-field-type'])
            field_data = escape_filter_chars(args['custom-field-data'])
            query = "(&(objectClass=User)(objectCategory=person)({}={}))".format(
                field_type, field_data)

        if args.get('attributes'):
            custom_attributes = args['attributes'].split(",")

        attributes = list(set(custom_attributes + DEFAULT_PERSON_ATTRIBUTES)
                          - set(argToList(args.get('attributes-to-exclude'))))

        entries = search_with_paging(
            query,
            default_base_dn,
            page_cookie=page_cookie,
            attributes=attributes,
            size_limit=limit,
            page_size=page_size
        )

        accounts = [account_entry(entry, custom_attributes) for entry in entries['flat']]
        if 'userAccountControl' in attributes:
            for user in entries['flat']:
                if user.get('userAccountControl'):
                    user_account_control = user.get('userAccountControl')[0]
                    user['userAccountControlFields'] = user_account_to_boolean_fields(user_account_control)

                    # display a literal translation of the numeric account control flag
                    if args.get('user-account-control-out', '') == 'true':
                        user['userAccountControl'] = COMMON_ACCOUNT_CONTROL_FLAGS.get(
                            user_account_control) or user_account_control
        entry_context = {
            'ActiveDirectory.Users(obj.dn == val.dn)': entries['flat'],
            # 'backward compatability' with ADGetUser script
            'Account(obj.ID == val.ID)': accounts,
            'ActiveDirectory(true)': {'UsersPageCookie': entries['page_cookie']} if entries['page_cookie'] else None
        }
        remove_nulls_from_dictionary(entry_context)

        demisto_entry = {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': entries['raw'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Active Directory - Get Users", entries['flat']),
            'EntryContext': entry_context
        }
        demisto.results(demisto_entry)


    def get_user_iam(default_base_dn, args, mapper_in, mapper_out):
        """Gets an AD user by User Profile.
        :param default_base_dn: The location in the DIT where the search will start
        :param args: Demisto args.
        :param mapper_in: Mapping AD user to User Profiles
        :param mapper_out: Mapping User Profiles to AD users.
        :return: User Profile of the AD user
        """
        try:
            user_profile = args.get("user-profile")
            user_profile_delta = args.get('user-profile-delta')
            default_attribute = "sAMAccountName"

            iam_user_profile = IAMUserProfile(user_profile=user_profile, user_profile_delta=user_profile_delta,
                                              mapper=mapper_out,
                                              incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)

            # we use the outgoing mapper to get all the AD attributes which will be later passed to search_with_paging()
            ad_user = iam_user_profile.map_object(mapper_name=mapper_out,
                                                  incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)

            value = ad_user.get(default_attribute)

            # removing keys with no values
            user = {k: v for k, v in ad_user.items() if v}
            attributes = list(user.keys())

            query = f'(&(objectClass=User)(objectCategory=person)({default_attribute}={value}))'
            entries = search_with_paging(
                query,
                default_base_dn,
                attributes=attributes,
                size_limit=1,
                page_size=1
            )

            if not entries.get('flat'):
                error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                iam_user_profile.set_result(action=IAMActions.GET_USER,
                                            success=False,
                                            error_code=error_code,
                                            error_message=error_message)
            else:
                user_account_control = get_user_activity_by_samaccountname(default_base_dn, value)
                ad_user["userAccountControl"] = user_account_control
                iam_user_profile.update_with_app_data(ad_user, mapper_in)
                iam_user_profile.set_result(success=True,
                                            email=ad_user.get('email'),
                                            username=ad_user.get('name'),
                                            action=IAMActions.GET_USER,
                                            details=ad_user,
                                            active=user_account_control)

            return iam_user_profile

        except Exception as e:
            error_code, _ = IAMErrors.BAD_REQUEST
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=str(e),
                                        action=IAMActions.GET_USER
                                        )
            return iam_user_profile


    def search_computers(default_base_dn, page_size):
        # this command is equivalent to ADGetComputer script

        args = demisto.args()
        attributes: list[str] = []
        custom_attributes: list[str] = []

        # default query - list all users (computer category)
        query = "(&(objectClass=user)(objectCategory=computer))"

        # query by user DN
        if args.get('dn'):
            query = "(&(objectClass=user)(objectCategory=computer)(distinguishedName={}))".format(args['dn'])

        # query by name
        if args.get('name'):
            query = "(&(objectClass=user)(objectCategory=computer)(name={}))".format(args['name'])

        # query by custom object attribute
        if args.get('custom-field-type'):
            if not args.get('custom-field-data'):
                raise Exception('Please specify "custom-field-data" as well when quering by "custom-field-type"')
            query = "(&(objectClass=user)(objectCategory=computer)({}={}))".format(
                args['custom-field-type'], args['custom-field-data'])

        size_limit = int(args.get('limit', '0'))
        page_cookie = args.get('page-cookie')
        if args.get('page-size'):
            page_size = arg_to_number(args['page-size'])
            size_limit = page_size

        if args.get('attributes'):
            custom_attributes = args['attributes'].split(",")
        attributes = list(set(custom_attributes + DEFAULT_COMPUTER_ATTRIBUTES))
        entries = search_with_paging(
            query,
            default_base_dn,
            attributes=attributes,
            page_size=page_size,
            size_limit=size_limit,
            page_cookie=page_cookie
        )

        endpoints = [endpoint_entry(entry, custom_attributes) for entry in entries['flat']]
        readable_output = tableToMarkdown("Active Directory - Get Computers", entries['flat'])

        if endpoints:
            results = CommandResults(
                readable_output=readable_output,
                outputs={
                    'ActiveDirectory.Computers(obj.dn == val.dn)': entries['flat'],
                    # 'backward compatability' with ADGetComputer script
                    'Endpoint(obj.ID == val.ID)': endpoints,
                    'ActiveDirectory(true)': {'ComputersPageCookie': entries['page_cookie']}
                },
                raw_response=entries['raw'],
            )
        else:
            results = CommandResults(
                readable_output=readable_output,
            )

        return_results(results)


    def search_group_members(default_base_dn, page_size):
        # this command is equivalent to ADGetGroupMembers script

        args = demisto.args()
        member_type = args.get('member-type')
        group_dn = args.get('group-dn')
        nested_search = '' if args.get('disable-nested-search') == 'true' else ':1.2.840.113556.1.4.1941:'
        time_limit = int(args.get('time_limit', 180))
        account_name = args.get('sAMAccountName')
        custom_attributes: list[str] = []

        default_attribute_mapping = {
            'person': DEFAULT_PERSON_ATTRIBUTES,
            'group': DEFAULT_GROUP_ATTRIBUTES,
            'computer': DEFAULT_COMPUTER_ATTRIBUTES,
        }
        default_attributes = default_attribute_mapping.get(member_type, DEFAULT_COMPUTER_ATTRIBUTES)

        if args.get('attributes'):
            custom_attributes = args['attributes'].split(",")

        attributes = list(set(custom_attributes + default_attributes))

        if member_type == 'group':
            query = "(&(objectCategory={})(memberOf{}={})(sAMAccountName={}))".format(member_type, nested_search, group_dn,
                                                                                      account_name)
        else:
            query = "(&(objectCategory={})(objectClass=user)(memberOf{}={})(sAMAccountName={}))"\
                .format(member_type, nested_search, group_dn, account_name)

        size_limit = int(args.get('limit', '0'))
        page_cookie = args.get('page-cookie')
        if args.get('page-size'):
            page_size = arg_to_number(args['page-size'])
            size_limit = page_size

        entries = search_with_paging(
            query,
            default_base_dn,
            attributes=attributes,
            page_size=page_size,
            time_limit=time_limit,
            size_limit=size_limit,
            page_cookie=page_cookie
        )
        members = [{'dn': entry['dn'], 'category': member_type} for entry in entries['flat']]
        demisto_entry = {
            'ContentsFormat': formats['json'],
            'Type': entryTypes['note'],
            'Contents': entries['raw'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown("Active Directory - Get Group Members", entries['flat']),
            'EntryContext': {
                'ActiveDirectory.Groups(obj.dn ==' + group_dn + ')': {
                    'dn': group_dn,
                    'members': members
                },
                'ActiveDirectory(true)': {'GroupsPageCookie': entries['page_cookie']}
            }
        }

        if member_type == 'person':
            demisto_entry['EntryContext']['ActiveDirectory.Users(obj.dn == val.dn)'] = entries['flat']
            demisto_entry['EntryContext']['Account'] = [account_entry(
                entry, custom_attributes) for entry in entries['flat']]
        elif member_type == 'computer':
            demisto_entry['EntryContext']['ActiveDirectory.Computers(obj.dn == val.dn)'] = entries['flat']
            demisto_entry['EntryContext']['Endpoint'] = [endpoint_entry(
                entry, custom_attributes) for entry in entries['flat']]
        elif member_type == 'group':
            demisto_entry['EntryContext']['ActiveDirectory.Groups(obj.dn == val.dn)'] = entries['flat']
            demisto_entry['EntryContext']['Group'] = [group_entry(
                entry, custom_attributes) for entry in entries['flat']]

        demisto.results(demisto_entry)


    ''' DATABASE OPERATIONS '''

    ''' CREATE OBJECT'''


    def create_user():
        assert connection is not None
        args = demisto.args()

        object_classes = ["top", "person", "organizationalPerson", "user"]
        user_dn = args.get('user-dn')
        username = args.get("username")
        password = args.get("password")
        custom_attributes = args.get('custom-attributes')
        attributes = {
            "sAMAccountName": username
        }

        # set common user attributes
        if args.get('display-name'):
            attributes['displayName'] = args['display-name']
        if args.get('description'):
            attributes['description'] = args['description']
        if args.get('email'):
            attributes['mail'] = args['email']
        if args.get('telephone-number'):
            attributes['telephoneNumber'] = args['telephone-number']
        if args.get('title'):
            attributes['title'] = args['title']

        # set user custom attributes
        if custom_attributes:
            try:
                custom_attributes = json.loads(custom_attributes)
            except Exception as e:
                demisto.info(str(e))
                raise Exception(
                    "Failed to parse custom attributes argument. Please see an example of this argument in the description."
                )
            for attribute_name, attribute_value in custom_attributes.items():
                # can run default attribute setting
                attributes[attribute_name] = attribute_value

        # add user
        success = connection.add(user_dn, object_classes, attributes)
        if not success:
            raise Exception("Failed to create user")

        # set user password
        success = connection.extend.microsoft.modify_password(user_dn, password)
        if not success:
            raise Exception("Failed to reset user password")

        # enable user and expire password
        modification = {
            # enable user
            'userAccountControl': [('MODIFY_REPLACE', NORMAL_ACCOUNT)],
            # set to 0, to force password change on next login
            "pwdLastSet": [('MODIFY_REPLACE', "0")]
        }
        modify_object(user_dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Created user with DN: {user_dn}"
        }
        demisto.results(demisto_entry)


    def create_user_iam(default_base_dn, args, mapper_out, disabled_users_group_cn):
        """Creates an AD user by User Profile.
        :param default_base_dn: The location in the DIT where the search will start
        :param args: Demisto args.
        :param mapper_out: Mapping User Profiles to AD users.
        :param disabled_users_group_cn: The disabled group cn, the user will be removed from this group when enabled
        :return: The user that was created
        """
        assert connection is not None
        try:

            user_profile = args.get("user-profile")
            user_profile_delta = args.get('user-profile-delta')
            iam_user_profile = IAMUserProfile(user_profile=user_profile, user_profile_delta=user_profile_delta,
                                              mapper=mapper_out, incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
            ad_user = iam_user_profile.map_object(mapper_name=mapper_out, incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)

            sam_account_name = ad_user.get("sAMAccountName")

            if not sam_account_name:
                raise DemistoException("User must have a sAMAccountName, please make sure a mapping "
                                       "exists in \"" + mapper_out + "\" outgoing mapper.")
            if not ad_user.get('ou'):
                raise DemistoException("User must have an Organizational Unit (OU). Please make sure you've added a "
                                       "transformer script which determines the OU of the user "
                                       "in \"" + mapper_out + "\" outgoing mapper, in the User Profile incident type "
                                                              "and schema type, under the \"ou\" field.")

            user_exists = check_if_user_exists_by_attribute(default_base_dn, "sAMAccountName", sam_account_name)

            if user_exists:
                iam_user_profile = update_user_iam(default_base_dn, args, False, mapper_out, disabled_users_group_cn)

            else:
                user_dn = generate_dn_and_remove_from_user_profile(default_base_dn, ad_user)
                object_classes = ["top", "person", "organizationalPerson", "user"]
                # ou and cn are updated from the dn, updating them seperatly can cause conflicts
                ad_user.pop('ou')
                ad_user.pop('cn')
                if manager_email := ad_user.get('manageremail'):
                    manager_dn = get_user_dn_by_email(default_base_dn, manager_email)
                    ad_user['manager'] = manager_dn
                success = connection.add(user_dn, object_classes, ad_user)
                if success:
                    iam_user_profile.set_result(success=True,
                                                email=ad_user.get('mail'),
                                                username=ad_user.get('sAMAccountName'),
                                                details=ad_user,
                                                action=IAMActions.CREATE_USER,
                                                active=False)  # the user should be activated with the IAMInitADUser script

                else:
                    error_msg = 'Please validate your instance configuration and make sure all of the ' \
                                'required attributes are mapped correctly in "' + mapper_out + '" outgoing mapper.'
                    raise DemistoException(error_msg)

            return iam_user_profile

        except Exception as e:
            error_code, _ = IAMErrors.BAD_REQUEST
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=str(e),
                                        action=IAMActions.CREATE_USER,
                                        )
            return iam_user_profile


    def get_iam_user_profile(user_profile, mapper_out):
        iam_user_profile = IAMUserProfile(user_profile=user_profile, mapper=mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
        ad_user = iam_user_profile.map_object(mapper_name=mapper_out, incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
        sam_account_name = ad_user.get("sAMAccountName")

        old_user_data = iam_user_profile.get_attribute('olduserdata')
        if old_user_data:
            iam_old_user_profile = IAMUserProfile(user_profile=old_user_data, mapper=mapper_out,
                                                  incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            ad_old_user = iam_old_user_profile.map_object(mapper_name=mapper_out,
                                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            sam_account_name = ad_old_user.get("sAMAccountName") or sam_account_name

        return iam_user_profile, ad_user, sam_account_name


    def update_user_iam(default_base_dn, args, create_if_not_exists, mapper_out, disabled_users_group_cn):
        """Update an AD user by User Profile.
        :param default_base_dn: The location in the DIT where the search will start
        :param args: Demisto args.
        :param create_if_not_exists: Created the user if it does not exists.
        :param mapper_out: Mapping User Profiles to AD users.
        :param disabled_users_group_cn: The disabled group cn, the user will be removed from this group when enabled
        :return: Updated User
        """
        assert connection is not None
        try:
            user_profile = args.get("user-profile")
            allow_enable = args.get('allow-enable') == 'true'

            iam_user_profile, ad_user, sam_account_name = get_iam_user_profile(user_profile, mapper_out)

            if not sam_account_name:
                raise DemistoException("User must have a sAMAccountName, please make sure a mapping "
                                       "exists in \"" + mapper_out + "\" outgoing mapper.")
            if not ad_user.get('ou'):
                raise DemistoException("User must have an Organizational Unit (OU). Please make sure you've added a "
                                       "transformer script which determines the OU of the user "
                                       "in \"" + mapper_out + "\" outgoing mapper, in the User Profile incident type "
                                                              "and schema type, under the \"ou\" field.")

            new_ou = ad_user.get("ou")
            user_exists = check_if_user_exists_by_attribute(default_base_dn, "sAMAccountName", sam_account_name)

            if not user_exists:
                if create_if_not_exists:
                    iam_user_profile = create_user_iam(default_base_dn, args, mapper_out, disabled_users_group_cn)
                else:
                    _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    iam_user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                skip=True,
                                                skip_reason=error_message)
            else:
                dn = user_dn(sam_account_name, default_base_dn)

                if allow_enable:
                    enable_user_iam(default_base_dn, dn, disabled_users_group_cn)

                # fields that can't be modified
                # notice that we are changing the ou and that effects the dn and cn
                for field in FIELDS_THAT_CANT_BE_MODIFIED:
                    if ad_user.get(field):
                        ad_user.pop(field)

                fail_to_modify = []
                if manager_email := ad_user.get('manageremail'):
                    manager_dn = get_user_dn_by_email(default_base_dn, manager_email)
                    ad_user['manager'] = manager_dn
                    ad_user.pop('manageremail')

                for key in ad_user:
                    modification = {key: [('MODIFY_REPLACE', ad_user.get(key))]}
                    success = connection.modify(dn, modification)
                    if not success:
                        fail_to_modify.append(key)

                ou_modified_succeed = modify_user_ou(dn, new_ou)
                if not ou_modified_succeed:
                    fail_to_modify.append("ou")

                if fail_to_modify:
                    error_list = '\n'.join(fail_to_modify)
                    error_message = f"Failed to modify the following attributes: {error_list}"
                    raise DemistoException(error_message)

                else:
                    active = get_user_activity_by_samaccountname(default_base_dn, sam_account_name)
                    iam_user_profile.set_result(success=True,
                                                email=ad_user.get('mail'),
                                                username=ad_user.get('sAMAccountName'),
                                                action=IAMActions.UPDATE_USER,
                                                details=ad_user,
                                                active=active)
            return iam_user_profile

        except Exception as e:
            error_code, _ = IAMErrors.BAD_REQUEST
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=str(e),
                                        action=IAMActions.UPDATE_USER
                                        )
            return iam_user_profile


    def create_contact():
        assert connection is not None
        args = demisto.args()

        object_classes = ["top", "person", "organizationalPerson", "contact"]
        contact_dn = args.get('contact-dn')

        # set contact attributes
        attributes: dict = {}
        if args.get('custom-attributes'):
            try:
                attributes = json.loads(args['custom-attributes'])
            except Exception as e:
                demisto.info(str(e))
                raise Exception(
                    'Failed to parse custom attributes argument. Please see an example of this argument in the argument.'
                )

        # set common user attributes
        if args.get('display-name'):
            attributes['displayName'] = args['display-name']
        if args.get('description'):
            attributes['description'] = args['description']
        if args.get('email'):
            attributes['mail'] = args['email']
        if args.get('telephone-number'):
            attributes['telephoneNumber'] = args['telephone-number']
        if args.get('title'):
            attributes['title'] = args['title']

        # add contact

        success = connection.add(contact_dn, object_classes, attributes)
        if not success:
            raise Exception("Failed to create contact")

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Created contact with DN: {contact_dn}"
        }
        demisto.results(demisto_entry)


    def create_group():
        assert connection is not None
        args = demisto.args()

        object_classes = ["top", "group"]
        dn = args.get('dn')
        group_name = args.get('name')
        group_type_map = {"security": "2147483650", "distribution": "2"}
        group_type = group_type_map[args.get("group-type")]
        if args.get('members'):
            members = args.get('members')
            attributes = {
                "samAccountName": group_name,
                "groupType": group_type,
                "member": members
            }
        else:
            attributes = {
                "samAccountName": group_name,
                "groupType": group_type
            }

        # create group
        success = connection.add(dn, object_classes, attributes)
        if not success:
            raise Exception("Failed to create group")

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Created group with DN: {dn}"
        }
        demisto.results(demisto_entry)


    ''' UPDATE OBJECT '''


    def modify_object(dn, modification):
        """
        modifies object in the DIT
        """
        assert connection is not None
        success = connection.modify(dn, modification)
        if not success:
            raise Exception("Failed to update object {} with the following modification: {}".format(
                dn, json.dumps(modification)))


    def update_user(default_base_dn):
        args = demisto.args()

        # get user DN
        sam_account_name = args.get('username')
        attribute_name = args.get('attribute-name')
        attribute_value = args.get('attribute-value')
        search_base = args.get('base-dn') or default_base_dn
        dn = user_dn(sam_account_name, search_base)

        modification = {}
        modification[attribute_name] = [('MODIFY_REPLACE', attribute_value)]

        # modify user
        modify_object(dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Updated user's {attribute_name} to {attribute_value} "
        }
        demisto.results(demisto_entry)


    def update_group(default_base_dn):
        args = demisto.args()

        sam_account_name = args.get('groupname')
        attribute_name = args.get('attributename')
        attribute_value = args.get('attributevalue')
        search_base = args.get('basedn') or default_base_dn
        dn = group_dn(sam_account_name, search_base)

        modification = {attribute_name: [('MODIFY_REPLACE', attribute_value)]}
        modify_object(dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Updated group's {attribute_name} to {attribute_value} "
        }
        demisto.results(demisto_entry)


    def update_contact():
        args = demisto.args()

        contact_dn = args.get('contact-dn')
        modification = {}
        modification[args.get('attribute-name')] = [('MODIFY_REPLACE', args.get('attribute-value'))]

        # modify
        modify_object(contact_dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "Updated contact's {} to: {} ".format(args.get('attribute-name'), args.get('attribute-value'))
        }
        demisto.results(demisto_entry)


    def modify_computer_ou(default_base_dn):
        assert connection is not None
        args = demisto.args()

        computer_name = args.get('computer-name')
        dn = computer_dn(computer_name, args.get('base-dn') or default_base_dn)

        success = connection.modify_dn(dn, f"CN={computer_name}", new_superior=args.get('full-superior-dn'))
        if not success:
            raise Exception("Failed to modify computer OU")

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "Moved computer {} to {}".format(computer_name, args.get('full-superior-dn'))
        }
        demisto.results(demisto_entry)


    def modify_user_ou_command(default_base_dn):
        assert connection is not None
        args = demisto.args()

        user_name = args.get('user-name')
        dn = user_dn(user_name, args.get('base-dn') or default_base_dn)
        success = modify_user_ou(dn, new_ou=args.get('full-superior-dn'))
        if not success:
            raise Exception("Failed to modify user OU")

        return f'Moved user {user_name} to {args.get("full-superior-dn")}'


    def expire_user_password(default_base_dn):
        args = demisto.args()

        # get user DN
        sam_account_name = args.get('username')
        search_base = args.get('base-dn') or default_base_dn
        dn = user_dn(sam_account_name, search_base)

        modification = {
            # set to 0, to force password change on next login
            "pwdLastSet": [('MODIFY_REPLACE', "0")]
        }

        # modify user
        modify_object(dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "Expired password successfully"
        }
        demisto.results(demisto_entry)


    def set_user_password(default_base_dn, port):
        assert connection is not None
        args = demisto.args()

        if port != 636:
            raise DemistoException('Port 636 is required for this action.')

        # get user DN
        sam_account_name = args.get('username')
        password = args.get('password')
        search_base = args.get('base-dn') or default_base_dn
        dn = user_dn(sam_account_name, search_base)

        # set user password
        success = connection.extend.microsoft.modify_password(dn, password)
        if not success:
            raise Exception("Failed to reset user password")

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "User password successfully set"
        }
        demisto.results(demisto_entry)


    def restore_user(default_base_dn: str, page_size: int) -> int:
        """
             Restore the user UserAccountControl flags.
             Args:
                 default_base_dn (str): The default base dn.
                 page_size (int): The page size to query.
             Returns:
                 flags (int): The UserAccountControl flags.
         """
        args = demisto.args()

        # default query - list all users
        query = "(&(objectClass=User)(objectCategory=person))"

        # query by sAMAccountName
        if args.get('username') or args.get('sAMAccountName'):
            username = escape_filter_chars(args['username']) if args.get('username') else escape_filter_chars(args['sAMAccountName'])
            query = f"(&(objectClass=User)(objectCategory=person)(sAMAccountName={username}))"

        attributes = list(set(DEFAULT_PERSON_ATTRIBUTES))

        entries = search_with_paging(
            query,
            default_base_dn,
            attributes=attributes,
            size_limit=0,
            page_size=page_size
        )
        if entries.get('flat'):
            return entries.get('flat')[0].get('userAccountControl')[0]
        return 0


    def turn_disable_flag_off(flags: int) -> int:
        """
            Turn off the ACCOUNTDISABLE flag in UserAccountControl flags.
            https://docs.microsoft.com/en-US/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties
             Args:
                 flags (int): The UserAccountControl flags to update.
             Returns:
                 flags (int): The UserAccountControl flags with the ACCOUNTDISABLE turned off.
         """
        return flags & ~(1 << (2 - 1))


    def enable_user(default_base_dn, default_page_size):
        args = demisto.args()
        account_options = NORMAL_ACCOUNT
        # get user DN
        sam_account_name = args.get('username')
        search_base = args.get('base-dn') or default_base_dn
        dn = user_dn(sam_account_name, search_base)

        if args.get('restore_user'):
            account_options = restore_user(search_base, default_page_size)

        # modify user
        modification = {
            'userAccountControl': [('MODIFY_REPLACE', turn_disable_flag_off(account_options))]
        }
        modify_object(dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"User {sam_account_name} was enabled"
        }
        demisto.results(demisto_entry)


    def disable_user(default_base_dn, default_page_size):
        args = demisto.args()

        # get user DN
        sam_account_name = args.get('username')
        search_base = args.get('base-dn') or default_base_dn
        dn = user_dn(sam_account_name, search_base)
        account_options = restore_user(search_base, default_page_size)

        # modify user
        modification = {
            'userAccountControl': [('MODIFY_REPLACE', (account_options | DISABLED_ACCOUNT))]
        }
        modify_object(dn, modification)

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"User {sam_account_name} was disabled"
        }
        demisto.results(demisto_entry)


    def enable_user_iam(default_base_dn, dn, disabled_users_group_cn):
        """Enables an AD user by User Profile.
        :param default_base_dn: The location in the DIT where the search will start
        :param dn: The users unique dn
        :param disabled_users_group_cn: The disabled group cn, the user will be removed from this group when enabled
        """
        modification = {
            'userAccountControl': [('MODIFY_REPLACE', PASSWORD_NOT_REQUIRED)]
        }
        modify_object(dn, modification)
        if disabled_users_group_cn:
            grp_dn = group_dn(disabled_users_group_cn, default_base_dn)
            success = microsoft.removeMembersFromGroups.ad_remove_members_from_groups(connection, [dn], [grp_dn], True)
            if not success:
                raise Exception(f'Failed to remove user from {disabled_users_group_cn} group')


    def disable_user_iam(default_base_dn, disabled_users_group_cn, args, mapper_out):
        """Disables an AD user by User Profile.
        :param default_base_dn: The location in the DIT where the search will start
        :param disabled_users_group_cn: The disabled group cn, the user will be added from this group when enabled
        :param args: Demisto args.
        :param mapper_out: Mapping User Profiles to AD users.
        :return: The disabled user
        """
        try:
            user_profile = args.get("user-profile")
            user_profile_delta = args.get('user-profile-delta')
            iam_user_profile = IAMUserProfile(user_profile=user_profile, user_profile_delta=user_profile_delta,
                                              mapper=mapper_out, incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            ad_user = iam_user_profile.map_object(mapper_name=mapper_out, incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)

            sam_account_name = ad_user.get("sAMAccountName")
            if not sam_account_name:
                raise DemistoException("User must have a sAMAccountName, please make sure a mapping "
                                       "exists in \"" + mapper_out + "\" outgoing mapper.")

            user_exists = check_if_user_exists_by_attribute(default_base_dn, "sAMAccountName", sam_account_name)
            if not user_exists:
                iam_user_profile.set_result(success=True, action=IAMActions.DISABLE_USER,
                                            skip=True, skip_reason="User doesn't exist")
                return iam_user_profile

            dn = user_dn(sam_account_name, default_base_dn)

            # modify user
            modification = {
                'userAccountControl': [('MODIFY_REPLACE', DISABLED_ACCOUNT)]
            }

            try:
                modify_object(dn, modification)
            except Exception as e:
                error_msg = 'Please validate your instance configuration and make sure all of the ' \
                            'required attributes are mapped correctly in "' + mapper_out + '" outgoing mapper.\n' \
                                                                                           'Error is: ' + str(e)
                raise DemistoException(error_msg)

            if disabled_users_group_cn:

                grp_dn = group_dn(disabled_users_group_cn, default_base_dn)
                success = microsoft.addMembersToGroups.ad_add_members_to_groups(connection, [dn], [grp_dn])
                if not success:
                    raise DemistoException('Failed to remove user from the group "' + disabled_users_group_cn + '".')

            iam_user_profile.set_result(success=True,
                                        email=ad_user.get('mail'),
                                        username=ad_user.get('sAMAccountName'),
                                        action=IAMActions.DISABLE_USER,
                                        details=ad_user,
                                        active=False)

            return iam_user_profile

        except Exception as e:
            error_code, _ = IAMErrors.BAD_REQUEST
            iam_user_profile.set_result(success=False,
                                        error_code=error_code,
                                        error_message=str(e),
                                        action=IAMActions.DISABLE_USER
                                        )
            return iam_user_profile


    def add_member_to_group(default_base_dn):
        args = demisto.args()

        search_base = args.get('base-dn') or default_base_dn

        # get the  dn of the member - either user or computer
        args_err = "Please provide either username or computer-name"
        member_dn = ''

        if args.get('username') and args.get('computer-name'):
            # both arguments passed
            raise Exception(args_err)
        if args.get('username'):
            member_dn = user_dn(args['username'], search_base)
        elif args.get('computer-name'):
            member_dn = computer_dn(args['computer-name'], search_base)
        else:
            # none of the arguments passed
            raise Exception(args_err)

        grp_dn = group_dn(args.get('group-cn'), search_base)

        success = microsoft.addMembersToGroups.ad_add_members_to_groups(connection, [member_dn], [grp_dn])
        if not success:
            raise Exception("Failed to add {} to group {}".format(
                args.get('username') or args.get('computer-name'),
                args.get('group_name')
            ))

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "Object with dn {} was added to group {}".format(member_dn, args.get('group-cn'))
        }
        demisto.results(demisto_entry)


    def remove_member_from_group(default_base_dn):
        args = demisto.args()

        search_base = args.get('base-dn') or default_base_dn

        # get the dn of the member - either user or computer
        args_err = "Pleade provide either username or computer-name"
        member_dn = ''

        if args.get('username') and args.get('computer-name'):
            # both arguments passed
            raise Exception(args_err)
        if args.get('username'):
            member_dn = user_dn(args['username'], search_base)
        elif args.get('computer-name'):
            member_dn = computer_dn(args['computer-name'], search_base)
        else:
            # none of the arguments passed
            raise Exception(args_err)

        grp_dn = group_dn(args.get('group-cn'), search_base)

        success = microsoft.removeMembersFromGroups.ad_remove_members_from_groups(connection, [member_dn], [grp_dn], True)
        if not success:
            raise Exception("Failed to remove {} from group {}".format(
                args.get('username') or args.get('computer-name'),
                args.get('group_name')
            ))

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "Object with dn {} removed from group {}".format(member_dn, args.get('group-cn'))
        }
        demisto.results(demisto_entry)


    def unlock_account(default_base_dn):
        args = demisto.args()

        # get user DN
        sam_account_name = args.get('username')
        search_base = args.get('base-dn') or default_base_dn
        dn = user_dn(sam_account_name, search_base)

        success = microsoft.unlockAccount.ad_unlock_account(connection, dn)
        if not success:
            raise Exception(f"Failed to unlock user {sam_account_name}")

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Unlocked user {sam_account_name}"
        }
        demisto.results(demisto_entry)


    ''' DELETE OBJECT '''


    def delete_user():
        # can actually delete any object...
        assert connection is not None
        success = connection.delete(demisto.args().get('user-dn'))
        if not success:
            raise Exception('Failed to delete user')

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': "Deleted object with dn {}".format(demisto.args().get('user-dn'))
        }
        demisto.results(demisto_entry)


    def delete_group():
        assert connection is not None
        args = demisto.args()

        dn = args.get('dn')

        # delete group
        success = connection.delete(dn)
        if not success:
            raise Exception("Failed to delete group")

        demisto_entry = {
            'ContentsFormat': formats['text'],
            'Type': entryTypes['note'],
            'Contents': f"Deleted group with DN: {dn}"
        }
        demisto.results(demisto_entry)


    def get_mapping_fields_command(search_base):
        ad_attributes = get_all_attributes(search_base)
        # add keys that are not attributes but can be used in mapping
        ad_attributes.extend(("dn", "manageremail"))

        incident_type_scheme = SchemeTypeMapping(type_name=IAMUserProfile.DEFAULT_INCIDENT_TYPE)

        for field in ad_attributes:
            incident_type_scheme.add_field(field, "Field")

        return GetMappingFieldsResponse([incident_type_scheme])


    '''
        TEST CONFIGURATION
        authenticate user credentials while initializing connection with AD server
        verify base DN is configured correctly
    '''


    def set_password_not_expire(default_base_dn):
        args = demisto.args()
        sam_account_name = args.get('username')
        pwd_n_exp = argToBoolean(args.get('value'))

        if not sam_account_name:
            raise Exception("Missing argument - You must specify a username (sAMAccountName).")

        # Query by sAMAccountName
        sam_account_name = escape_filter_chars(sam_account_name)
        query = f"(&(objectClass=User)(objectCategory=person)(sAMAccountName={sam_account_name}))"
        entries = search_with_paging(query, default_base_dn, attributes='userAccountControl')

        if not check_if_user_exists_by_attribute(default_base_dn, "sAMAccountName", sam_account_name):
            return_error(f"sAMAccountName {sam_account_name} was not found.")

        if user := entries.get('flat'):
            user = user[0]
            if user_account_control := user.get('userAccountControl'):
                user_account_control = user_account_control[0]

            # Check if UAC flag for "Password Never Expire" (0x10000) is set to True or False:
            if pwd_n_exp:
                # Sets the bit 16 to 1
                user_account_control |= 1 << 16
                content_output = (f"AD account {sam_account_name} has set \"password never expire\" attribute. "
                                  f"Value is set to True")
            else:
                # Clears the bit 16 to 0
                user_account_control &= ~(1 << 16)
                content_output = (f"AD account {sam_account_name} has cleared \"password never expire\" attribute. "
                                  f"Value is set to False")

            attribute_name = 'userAccountControl'
            attribute_value = user_account_control
            dn = user_dn(sam_account_name, default_base_dn)
            modification = {attribute_name: [('MODIFY_REPLACE', attribute_value)]}

            # Modify user
            modify_object(dn, modification)
            demisto_entry = {
                'ContentsFormat': formats['text'],
                'Type': entryTypes['note'],
                'Contents': content_output
            }
            demisto.results(demisto_entry)

        else:
            raise DemistoException(f"Unable to fetch attribute 'userAccountControl' for user {sam_account_name}.")


    def test_credentials_command(server_ip, ntlm_connection):
        args = demisto.args()
        username = args.get('username')
        server = Server(server_ip, get_info='ALL')
        try:
            connection = create_connection(
                server=server,
                server_ip=server_ip,
                username=username,
                password=args.get('password'),
                ntlm_connection=argToBoolean(ntlm_connection),
                auto_bind=True,
            )
            connection.unbind()
        except LDAPBindError:
            raise DemistoException(f"Credential test with username {username} was not successful.")
        return CommandResults(
            outputs_prefix='ActiveDirectory.ValidCredentials',
            outputs_key_field='username',
            outputs=username,
            readable_output=f"Credential test with username {username} succeeded."
        )


    def create_connection(server: Server, server_ip: str, username: str, password: str, ntlm_connection: bool, auto_bind: str | bool):
        domain_name = server_ip + '\\' + username if '\\' not in username else username
        # open socket and bind to server
        return Connection(server, domain_name, password=password, authentication=NTLM, auto_bind=auto_bind) if ntlm_connection \
            else Connection(server, user=username, password=password, auto_bind=auto_bind)


    def get_auto_bind_value(secure_connection, unsecure) -> str:
        """
            Returns the proper auto bind value according to the desirable connection type.
            The 'TLS' in the auto_bind parameter refers to the STARTTLS LDAP operation, that can be performed only on a
            cleartext connection (unsecure connection - port 389).

            If the Client's connection type is Start TLS - the secure level will be upgraded to TLS during the
            connection bind itself, and thus we use the AUTO_BIND_TLS_BEFORE_BIND constant.

            If the Client's connection type is Start TLS and the 'Trust any certificate' is unchecked -
            For backwards compatibility - we use the AUTO_BIND_TLS_BEFORE_BIND constant as well.

            If the Client's connection type is SSL - the connection is already secured (server was initialized with
            use_ssl=True and port 636) and therefore we use the AUTO_BIND_NO_TLS constant.

            Otherwise, the Client's connection type is None - the connection is unsecured and should stay unsecured,
            thus we use the AUTO_BIND_NO_TLS constant here as well.
        """
        if secure_connection == START_TLS:
            auto_bind = AUTO_BIND_TLS_BEFORE_BIND

        elif secure_connection == TLS and not unsecure:  # BC
            auto_bind = AUTO_BIND_TLS_BEFORE_BIND

        else:
            auto_bind = AUTO_BIND_NO_TLS

        return auto_bind


    def main():
        """ INSTANCE CONFIGURATION """
        params = demisto.params()
        command = demisto.command()
        args = demisto.args()

        server_ip = params.get('server_ip')
        username = params.get('credentials')['identifier']
        password = params.get('credentials')['password']
        default_base_dn = params.get('base_dn')
        secure_connection = params.get('secure_connection')
        ssl_version = params.get('ssl_version', 'None')
        default_page_size = int(params.get('page_size'))
        ntlm_auth = params.get('ntlm')
        insecure = params.get('unsecure', False)
        port = params.get('port')

        disabled_users_group_cn = params.get('group-cn')
        create_if_not_exists = params.get('create-if-not-exists')
        mapper_in = params.get('mapper-in', DEFAULT_INCOMING_MAPPER)
        mapper_out = params.get('mapper-out', DEFAULT_OUTGOING_MAPPER)

        if port:
            # port was configured, cast to int
            port = int(port)
        last_log_detail_level = None
        try:
            set_library_log_hide_sensitive_data(True)
            if is_debug_mode():
                demisto.info('debug-mode: setting library log detail to EXTENDED')
                last_log_detail_level = get_library_log_detail_level()
                set_library_log_detail_level(EXTENDED)

            server = initialize_server(server_ip, port, secure_connection, insecure, ssl_version)

            global connection
            auto_bind = get_auto_bind_value(secure_connection, insecure)

            try:
                # user example: domain\user
                connection = create_connection(
                    server=server,
                    server_ip=server_ip,
                    username=username,
                    password=password,
                    ntlm_connection=ntlm_auth,
                    auto_bind=auto_bind)
            except Exception as e:
                err_msg = str(e)
                demisto.info(f"Failed connect to: {server_ip}:{port}. {type(e)}:{err_msg}\n"
                             f"Trace:\n{traceback.format_exc()}")
                if isinstance(e, LDAPBindError):
                    message = (f'Failed to bind server. Please validate that the credentials are configured correctly.\n'
                               f'Additional details: {err_msg}.\n')
                elif isinstance(e, LDAPSocketOpenError | LDAPSocketReceiveError | LDAPStartTLSError):
                    message = f'Failed to access LDAP server. \n Additional details: {err_msg}.\n'
                    if not insecure and secure_connection in (SSL, START_TLS):
                        message += ' Try using: "Trust any certificate" option.\n'
                else:
                    message = ("Failed to access LDAP server. Please validate the server host and port are configured "
                               "correctly.\n")
                return_error(message)
                return None

            demisto.info(f'Established connection with AD LDAP server.\nLDAP Connection Details: {connection}')

            if not base_dn_verified(default_base_dn):
                message = (f"Failed to verify the base DN configured for the instance.\n"
                           f"Last connection result: {json.dumps(connection.result)}\n"
                           f"Last error from LDAP server: {json.dumps(connection.last_error)}")
                return_error(message)
                return None

            demisto.info(f'Verified base DN "{default_base_dn}"')

            ''' COMMAND EXECUTION '''

            if command == 'test-module':
                if connection.user == '':
                    # Empty response means you have no authentication status on the server, so you are an anonymous user.
                    raise Exception("Failed to authenticate user")
                demisto.results('ok')

            elif command == 'ad-search':
                free_search(default_base_dn, default_page_size)

            elif command == 'ad-modify-password-never-expire':
                set_password_not_expire(default_base_dn)

            elif command == 'ad-expire-password':
                expire_user_password(default_base_dn)

            elif command == 'ad-set-new-password':
                set_user_password(default_base_dn, port)

            elif command == 'ad-unlock-account':
                unlock_account(default_base_dn)

            elif command == 'ad-disable-account':
                disable_user(default_base_dn, default_page_size)

            elif command == 'ad-enable-account':
                enable_user(default_base_dn, default_page_size)

            elif command == 'ad-remove-from-group':
                remove_member_from_group(default_base_dn)

            elif command == 'ad-add-to-group':
                add_member_to_group(default_base_dn)

            elif command == 'ad-create-user':
                create_user()

            elif command == 'ad-delete-user':
                delete_user()

            elif command == 'ad-update-user':
                update_user(default_base_dn)

            elif command == 'ad-update-group':
                update_group(default_base_dn)

            elif command == 'ad-modify-computer-ou':
                modify_computer_ou(default_base_dn)

            elif command == 'ad-modify-user-ou':
                return_results(modify_user_ou_command(default_base_dn))

            elif command == 'ad-create-contact':
                create_contact()

            elif command == 'ad-update-contact':
                update_contact()

            elif command == 'ad-get-user':
                search_users(default_base_dn, default_page_size)

            elif command == 'ad-get-computer':
                search_computers(default_base_dn, default_page_size)

            elif command == 'ad-get-group-members':
                search_group_members(default_base_dn, default_page_size)

            elif command == 'ad-create-group':
                create_group()

            elif command == 'ad-delete-group':
                delete_group()

            elif command == 'ad-test-credentials':
                return return_results(test_credentials_command(server_ip, ntlm_connection=ntlm_auth))

            # IAM commands
            elif command == 'iam-get-user':
                user_profile = get_user_iam(default_base_dn, args, mapper_in, mapper_out)
                return return_results(user_profile)

            elif command == 'iam-create-user':
                user_profile = create_user_iam(default_base_dn, args, mapper_out, disabled_users_group_cn)
                return return_results(user_profile)

            elif command == 'iam-update-user':
                user_profile = update_user_iam(default_base_dn, args, create_if_not_exists, mapper_out,
                                               disabled_users_group_cn)
                return return_results(user_profile)

            elif command == 'iam-disable-user':
                user_profile = disable_user_iam(default_base_dn, disabled_users_group_cn, args, mapper_out)
                return return_results(user_profile)

            elif command == 'get-mapping-fields':
                mapping_fields = get_mapping_fields_command(default_base_dn)
                return return_results(mapping_fields)

            else:
                raise NotImplementedError(f'Command {command} is not implemented')

        except Exception as e:
            message = str(e)
            if connection:
                message += (f"\nLast connection result: {json.dumps(connection.result)}\n"
                            f"Last error from LDAP server: {connection.last_error}")
            return_error(message)
            return None

        finally:
            # disconnect and close the connection
            if connection:
                connection.unbind()
            if last_log_detail_level:
                set_library_log_detail_level(last_log_detail_level)



    ### GENERATED CODE ###: from IAMApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('IAMApiModule', 'start', __line__(), wrapper=-3)





    class IAMErrors(object):
        """
        An enum class to manually handle errors in IAM integrations
        :return: None
        :rtype: ``None``
        """
        BAD_REQUEST = 400, 'Bad request - failed to perform operation'
        USER_DOES_NOT_EXIST = 404, 'User does not exist'
        USER_ALREADY_EXISTS = 409, 'User already exists'


    class IAMActions(object):
        """
        Enum: contains all the IAM actions (e.g. get, update, create, etc.)
        :return: None
        :rtype: ``None``
        """
        GET_USER = 'get'
        UPDATE_USER = 'update'
        CREATE_USER = 'create'
        DISABLE_USER = 'disable'
        ENABLE_USER = 'enable'


    class IAMVendorActionResult:
        """ This class is used in IAMUserProfile class to represent actions data.
        :return: None
        :rtype: ``None``
        """

        def __init__(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                     error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            self._brand = demisto.callingContext.get('context', {}).get('IntegrationBrand')
            self._instance_name = demisto.callingContext.get('context', {}).get('IntegrationInstance')
            self._success = success
            self._active = active
            self._iden = iden
            self._username = username
            self._email = email
            self._error_code = error_code
            self._error_message = error_message
            self._details = details
            self._skip = skip
            self._skip_reason = skip_reason
            self._action = action
            self._return_error = return_error

        def should_return_error(self):
            return self._return_error

        def create_outputs(self):
            """ Sets the outputs in `_outputs` attribute.
            """
            outputs = {
                'brand': self._brand,
                'instanceName': self._instance_name,
                'action': self._action,
                'success': self._success,
                'active': self._active,
                'id': self._iden,
                'username': self._username,
                'email': self._email,
                'errorCode': self._error_code,
                'errorMessage': self._error_message,
                'details': self._details,
                'skipped': self._skip,
                'reason': self._skip_reason
            }
            return outputs

        def create_readable_outputs(self, outputs):
            """ Sets the human readable output in `_readable_output` attribute.

            :param outputs: (dict) the command outputs.
            """
            title = self._action.title() + ' User Results ({})'.format(self._brand)

            if not self._skip:
                headers = ["brand", "instanceName", "success", "active", "id", "username",
                           "email", "errorCode", "errorMessage", "details"]
            else:
                headers = ["brand", "instanceName", "skipped", "reason"]

            readable_output = tableToMarkdown(
                name=title,
                t=outputs,
                headers=headers,
                removeNull=True
            )

            return readable_output


    class IAMUserProfile:
        """ A User Profile object class for IAM integrations.

        :type _user_profile: ``str``
        :param _user_profile: The user profile information.

        :type _user_profile_delta: ``str``
        :param _user_profile_delta: The user profile delta.

        :type _vendor_action_results: ``list``
        :param _vendor_action_results: A List of data returned from the vendor.

        :return: None
        :rtype: ``None``
        """

        DEFAULT_INCIDENT_TYPE = 'User Profile'
        CREATE_INCIDENT_TYPE = 'User Profile - Create'
        UPDATE_INCIDENT_TYPE = 'User Profile - Update'
        DISABLE_INCIDENT_TYPE = 'User Profile - Disable'
        ENABLE_INCIDENT_TYPE = 'User Profile - Enable'

        def __init__(self, user_profile, mapper: str, incident_type: str, user_profile_delta=None):
            self._user_profile = safe_load_json(user_profile)
            # Mapping is added here for GET USER commands, where we need to map Cortex XSOAR fields to the given app fields.
            self.mapped_user_profile = None
            self.mapped_user_profile = self.map_object(mapper, incident_type, map_old_data=True) if \
                mapper else self._user_profile
            self._user_profile_delta = safe_load_json(user_profile_delta) if user_profile_delta else {}
            self._vendor_action_results: List = []

        def get_attribute(self, item, use_old_user_data=False, user_profile_data: Optional[Dict] = None):
            user_profile = user_profile_data if user_profile_data else self._user_profile
            if use_old_user_data and user_profile.get('olduserdata', {}).get(item):
                return user_profile.get('olduserdata', {}).get(item)
            return user_profile.get(item)

        def to_entry(self):
            """ Generates a XSOAR IAM entry from the data in _vendor_action_results.
            Note: Currently we are using only the first element of the list, in the future we will support multiple results.

            :return: A XSOAR entry.
            :rtype: ``dict``
            """

            outputs = self._vendor_action_results[0].create_outputs()
            readable_output = self._vendor_action_results[0].create_readable_outputs(outputs)

            entry_context = {
                'IAM.UserProfile(val.email && val.email == obj.email)': self._user_profile,
                'IAM.Vendor(val.instanceName && val.instanceName == obj.instanceName && '
                'val.email && val.email == obj.email)': outputs
            }

            return_entry = {
                'ContentsFormat': EntryFormat.JSON,
                'Contents': outputs,
                'EntryContext': entry_context
            }

            if self._vendor_action_results[0].should_return_error():
                return_entry['Type'] = EntryType.ERROR
            else:
                return_entry['Type'] = EntryType.NOTE
                return_entry['HumanReadable'] = readable_output

            return return_entry

        def return_outputs(self):
            return_results(self.to_entry())

        def set_result(self, success=True, active=None, iden=None, username=None, email=None, error_code=None,
                       error_message=None, details=None, skip=False, skip_reason=None, action=None, return_error=False):
            """ Sets the outputs and readable outputs attributes according to the given arguments.

            :param success: (bool) whether or not the command succeeded.
            :param active:  (bool) whether or not the user status is active.
            :param iden: (str) the user ID.
            :param username: (str) the username of the user.
            :param email:  (str) the email of the user.
            :param error_code: (str or int) the error code of the response, if exists.
            :param error_message: (str) the error details of the response, if exists.
            :param details: (dict) the full response.
            :param skip: (bool) whether or not the command is skipped.
            :param skip_reason: (str) If the command is skipped, describes the reason.
            :param action: (IAMActions) An enum object represents the action taken (get, update, create, etc).
            :param return_error: (bool) Whether or not to return an error entry.
            """
            if not email:
                email = self.get_attribute('email')

            if not details:
                details = self.mapped_user_profile

            vendor_action_result = IAMVendorActionResult(
                success=success,
                active=active,
                iden=iden,
                username=username,
                email=email,
                error_code=error_code,
                error_message=error_message if error_message else '',
                details=details,
                skip=skip,
                skip_reason=skip_reason if skip_reason else '',
                action=action,
                return_error=return_error
            )

            self._vendor_action_results.append(vendor_action_result)

        def map_object(self, mapper_name, incident_type, map_old_data: bool = False):
            """ Returns the user data, in an application data format.

            :type mapper_name: ``str``
            :param mapper_name: The outgoing mapper from XSOAR to the application.

            :type incident_type: ``str``
            :param incident_type: The incident type used.

            :type map_old_data ``bool``
            :param map_old_data: Whether to map old data as well.

            :return: the user data, in the app data format.
            :rtype: ``dict``
            """
            if self.mapped_user_profile:
                if not map_old_data:
                    return {k: v for k, v in self.mapped_user_profile.items() if k != 'olduserdata'}
                return self.mapped_user_profile
            if incident_type not in [IAMUserProfile.CREATE_INCIDENT_TYPE, IAMUserProfile.UPDATE_INCIDENT_TYPE,
                                     IAMUserProfile.DISABLE_INCIDENT_TYPE,
                                     IAMUserProfile.ENABLE_INCIDENT_TYPE]:
                raise DemistoException('You must provide a valid incident type to the map_object function.')
            if not self._user_profile:
                raise DemistoException('You must provide the user profile data.')
            app_data = demisto.mapObject(self._user_profile, mapper_name, incident_type)
            if map_old_data and 'olduserdata' in self._user_profile:
                app_data['olduserdata'] = demisto.mapObject(self._user_profile.get('olduserdata', {}), mapper_name,
                                                            incident_type)
            return app_data

        def update_with_app_data(self, app_data, mapper_name, incident_type=None):
            """ updates the user_profile attribute according to the given app_data

            :type app_data: ``dict``
            :param app_data: The user data in app

            :type mapper_name: ``str``
            :param mapper_name: Incoming mapper name

            :type incident_type: ``str``
            :param incident_type: Optional - incident type
            """
            if not incident_type:
                incident_type = IAMUserProfile.DEFAULT_INCIDENT_TYPE
            if not isinstance(app_data, dict):
                app_data = safe_load_json(app_data)
            self._user_profile = demisto.mapObject(app_data, mapper_name, incident_type)

        def get_first_available_iam_user_attr(self, iam_attrs: List[str], use_old_user_data: bool = False):
            # Special treatment for ID field, because he is not included in outgoing mappers.
            for iam_attr in iam_attrs:
                # Special treatment for ID field, because he is not included in outgoing mappers.
                if iam_attr == 'id':
                    if attr_value := self.get_attribute(iam_attr, use_old_user_data):
                        return iam_attr, attr_value
                if attr_value := self.get_attribute(iam_attr, use_old_user_data, self.mapped_user_profile):
                    # Special treatment for emails, as mapper maps it to a list object.
                    if iam_attr == 'emails' and not isinstance(attr_value, str):
                        if isinstance(attr_value, dict):
                            attr_value = attr_value.get('value')
                        elif isinstance(attr_value, list):
                            if not attr_value:
                                continue
                            attr_value = next((email.get('value') for email in attr_value if email.get('primary', False)),
                                              attr_value[0].get('value', ''))
                    return iam_attr, attr_value

            raise DemistoException('Your user profile argument must contain at least one attribute that is mapped into one'
                                   f' of the following attributes in the outgoing mapper: {iam_attrs}')

        def set_user_is_already_disabled(self, details):
            self.set_result(
                action=IAMActions.DISABLE_USER,
                skip=True,
                skip_reason='User is already disabled.',
                details=details
            )

        def set_user_is_already_enabled(self, details):
            self.set_result(
                action=IAMActions.ENABLE_USER,
                skip=True,
                skip_reason='User is already enabled.',
                details=details
            )


    class IAMUserAppData:
        """ Holds user attributes retrieved from an application.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, user_id, username, is_active, app_data, email=None):
            self.id = user_id
            self.username = username
            self.is_active = is_active
            self.full_data = app_data
            self.email = email


    class IAMCommand:
        """ A class that implements the IAM CRUD commands - should be used.

        :type id: ``str``
        :param id: The ID of the user.

        :type username: ``str``
        :param username: The username of the user.

        :type is_active: ``bool``
        :param is_active: Whether or not the user is active in the application.

        :type full_data: ``dict``
        :param full_data: The full data of the user in the application.

        :return: None
        :rtype: ``None``
        """

        def __init__(self, is_create_enabled=True, is_enable_enabled=True, is_disable_enabled=True, is_update_enabled=True,
                     create_if_not_exists=True, mapper_in=None, mapper_out=None, get_user_iam_attrs=None):
            """ The IAMCommand c'tor

            :param is_create_enabled: (bool) Whether or not to allow creating users in the application.
            :param is_enable_enabled: (bool) Whether or not to allow enabling users in the application.
            :param is_disable_enabled: (bool) Whether or not to allow disabling users in the application.
            :param is_update_enabled: (bool) Whether or not to allow updating users in the application.
            :param create_if_not_exists: (bool) Whether or not to create a user if does not exist in the application.
            :param mapper_in: (str) Incoming mapper from the application to Cortex XSOAR
            :param mapper_out: (str) Outgoing mapper from the Cortex XSOAR to the application
            :param get_user_iam_attrs (List[str]): List of IAM attributes supported by integration by precedence
                                                            order to get user details.
            """
            if get_user_iam_attrs is None:
                get_user_iam_attrs = ['email']
            self.is_create_enabled = is_create_enabled
            self.is_enable_enabled = is_enable_enabled
            self.is_disable_enabled = is_disable_enabled
            self.is_update_enabled = is_update_enabled
            self.create_if_not_exists = create_if_not_exists
            self.mapper_in = mapper_in
            self.mapper_out = mapper_out
            self.get_user_iam_attrs = get_user_iam_attrs

        def get_user(self, client, args):
            """ Searches a user in the application and updates the user profile object with the data.
                If not found, the error details will be resulted instead.
            :param client: (Client) The integration Client object that implements a get_user() method
            :param args: (dict) The `iam-get-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            try:
                iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(self.get_user_iam_attrs)
                user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                if not user_app_data:
                    error_code, error_message = IAMErrors.USER_DOES_NOT_EXIST
                    user_profile.set_result(action=IAMActions.GET_USER,
                                            success=False,
                                            error_code=error_code,
                                            error_message=error_message)
                else:
                    user_profile.update_with_app_data(user_app_data.full_data, self.mapper_in)
                    user_profile.set_result(
                        action=IAMActions.GET_USER,
                        active=user_app_data.is_active,
                        iden=user_app_data.id,
                        email=user_profile.get_attribute('email') or user_app_data.email,
                        username=user_app_data.username,
                        details=user_app_data.full_data
                    )

            except Exception as e:
                client.handle_exception(user_profile, e, IAMActions.GET_USER)

            return user_profile

        def disable_user(self, client, args):
            """ Disables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user() and disable_user() methods
            :param args: (dict) The `iam-disable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_disable_enabled:
                user_profile.set_result(action=IAMActions.DISABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.DISABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if user_app_data.is_active:
                            disabled_user = client.disable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.DISABLE_USER,
                                active=False,
                                iden=disabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=disabled_user.username,
                                details=disabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_disabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.DISABLE_USER)

            return user_profile

        def enable_user(self, client, args):
            """ Enables a user in the application and updates the user profile object with the updated data.
                If not found, the command will be skipped.

            :param client: (Client) The integration Client object that implements get_user(),
                                    enable_user() and handle_exception methods
            :param args: (dict) The `iam-enable-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            if not self.is_enable_enabled:
                user_profile.set_result(action=IAMActions.ENABLE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if not user_app_data:
                        _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                        user_profile.set_result(action=IAMActions.ENABLE_USER,
                                                skip=True,
                                                skip_reason=error_message)
                    else:
                        if not user_app_data.is_active:
                            enabled_user = client.enable_user(user_app_data.id)
                            user_profile.set_result(
                                action=IAMActions.ENABLE_USER,
                                active=True,
                                iden=enabled_user.id,
                                email=user_profile.get_attribute('email') or user_app_data.email,
                                username=enabled_user.username,
                                details=enabled_user.full_data
                            )
                        else:
                            user_profile.set_user_is_already_enabled(user_app_data.full_data)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.ENABLE_USER)

            return user_profile

        def create_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If a user in the app already holds the email in the given user profile, updates
                its data with the given data.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-create-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.CREATE_INCIDENT_TYPE)
            if not self.is_create_enabled:
                user_profile.set_result(action=IAMActions.CREATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        # if user exists, update it
                        user_profile = self.update_user(client, args)

                    else:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.CREATE_INCIDENT_TYPE)
                        created_user = client.create_user(app_profile)
                        user_profile.set_result(
                            action=IAMActions.CREATE_USER,
                            active=created_user.is_active,
                            iden=created_user.id,
                            email=user_profile.get_attribute('email') or created_user.email,
                            username=created_user.username,
                            details=created_user.full_data
                        )

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.CREATE_USER)

            return user_profile

        def update_user(self, client, args):
            """ Creates a user in the application and updates the user profile object with the data.
                If the user is disabled and `allow-enable` argument is `true`, also enables the user.
                If the user does not exist in the app and the `create-if-not-exist` parameter is checked, creates the user.

            :param client: (Client) A Client object that implements get_user(), create_user() and update_user() methods
            :param args: (dict) The `iam-update-user` command arguments
            :return: (IAMUserProfile) The user profile object.
            """
            user_profile = IAMUserProfile(user_profile=args.get('user-profile'), mapper=self.mapper_out,
                                          incident_type=IAMUserProfile.UPDATE_INCIDENT_TYPE)
            allow_enable = args.get('allow-enable') == 'true' and self.is_enable_enabled
            if not self.is_update_enabled:
                user_profile.set_result(action=IAMActions.UPDATE_USER,
                                        skip=True,
                                        skip_reason='Command is disabled.')
            else:
                try:
                    iam_attribute, iam_attribute_val = user_profile.get_first_available_iam_user_attr(
                        self.get_user_iam_attrs, use_old_user_data=True)
                    user_app_data = client.get_user(iam_attribute, iam_attribute_val)
                    if user_app_data:
                        app_profile = user_profile.map_object(self.mapper_out, IAMUserProfile.UPDATE_INCIDENT_TYPE)

                        if allow_enable and not user_app_data.is_active:
                            client.enable_user(user_app_data.id)

                        updated_user = client.update_user(user_app_data.id, app_profile)

                        if updated_user.is_active is None:
                            updated_user.is_active = True if allow_enable else user_app_data.is_active

                        user_profile.set_result(
                            action=IAMActions.UPDATE_USER,
                            active=updated_user.is_active,
                            iden=updated_user.id,
                            email=user_profile.get_attribute('email') or updated_user.email or user_app_data.email,
                            username=updated_user.username,
                            details=updated_user.full_data
                        )
                    else:
                        if self.create_if_not_exists:
                            user_profile = self.create_user(client, args)
                        else:
                            _, error_message = IAMErrors.USER_DOES_NOT_EXIST
                            user_profile.set_result(action=IAMActions.UPDATE_USER,
                                                    skip=True,
                                                    skip_reason=error_message)

                except Exception as e:
                    client.handle_exception(user_profile, e, IAMActions.UPDATE_USER)

            return user_profile


    def get_first_primary_email_by_scim_schema(res: Dict):
        return next((email.get('value') for email in res.get('emails', []) if email.get('primary')), None)

    register_module_line('IAMApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    # python2 uses __builtin__ python3 uses builtins
    if __name__ in ('__builtin__', 'builtins', '__main__'):
        main()

    register_module_line('Active Directory Query v2', 'end', __line__())
  subtype: python3
  type: python
sectionorder:
- Connect
- Collect
system: true
